<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Black Cab Unite v7.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#000000">
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging-compat.js"></script>
  <style>
    /* ... (your existing CSS - unchanged) ... */
    body { 
      margin:0; <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Black Cab Unite v7.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
  <!-- PWA -->
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#000000">
  <!-- Firebase Compat SDKs (used for FCM) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging-compat.js"></script>
  <!-- Firebase Modular SDKs (used for Firestore/Auth/Real-time Chat) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, query, where, orderBy, onSnapshot, addDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Export Firebase functions to the global scope for use in the main script block
    window.initializeApp = initializeApp;
    window.getAuth = getAuth;
    window.signInAnonymously = signInAnonymously;
    window.signInWithCustomToken = signInWithCustomToken;
    window.onAuthStateChanged = onAuthStateChanged;
    window.signOut = signOut;
    window.getFirestore = getFirestore;
    window.collection = collection;
    window.query = query;
    window.where = where;
    window.orderBy = orderBy;
    window.onSnapshot = onSnapshot;
    window.addDoc = addDoc;
    window.serverTimestamp = serverTimestamp;
    window.setLogLevel = setLogLevel; // Export actual setLogLevel
  </script>
  
  <style>
    :root {
      --primary: #000000;
      --secondary: #1f6feb;
      --success: #28a745;
      --warning: #ff7b00;
      --danger: #dc3545;
      --bg-dark: #2c3e50;
      --bg-light: #ecf0f1;
      --card-bg: #ffffff;
      --text-light: #f7f7f7;
      --text-dark: #34495e;
      --shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    body { 
      margin:0; 
      font-family:'Inter', system-ui, -apple-system, "Segoe UI", sans-serif; 
      background:var(--bg-light); 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      overflow:hidden;
      color: var(--text-dark);
    }
    .app-header {
      background: var(--primary);
      color: var(--text-light);
      padding: 10px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: var(--shadow);
      z-index: 10;
    }
    #appTitleContainer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      cursor: pointer;
      padding: 5px;
      border-radius: 8px;
    }
    #appTitleContainer h1 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 700;
    }
    #statusDisplay {
      font-size: 0.8rem;
      font-weight: 400;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--warning);
    }
    .status-dot.active { background: var(--success); }
    .status-dot.idle { background: var(--warning); }
    .status-dot.busy { background: var(--danger); }
    .status-dot.offline { background: var(--bg-dark); }

    /* Dropdown Status Picker */
    #statusDropdown {
      position: absolute;
      top: 55px;
      left: 10px;
      background: var(--card-bg);
      border-radius: 8px;
      box-shadow: var(--shadow);
      z-index: 20;
      padding: 8px 0;
      display: none;
      flex-direction: column;
      min-width: 150px;
      border: 1px solid #ddd;
    }
    .status-option {
      padding: 10px 15px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text-dark);
    }
    .status-option:hover {
      background: var(--bg-light);
    }
    .status-option.active {
      background: var(--secondary);
      color: var(--text-light);
    }

    .menu-nav {
      display: flex;
      background: var(--bg-light);
      border-radius: 12px;
      overflow: hidden;
      padding: 5px;
    }
    .nav-btn {
      flex: 1;
      background: none;
      border: none;
      padding: 10px 15px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s, color 0.2s;
      color: var(--text-dark);
      white-space: nowrap; /* Prevent wrapping in narrow screens */
    }
    .nav-btn.active {
      background: var(--secondary);
      color: var(--text-light);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    #map { 
      flex:1; 
      width:100%;
      height:100%;
      z-index:1;
    }

    .main-content {
      position: relative;
      flex: 1;
    }
    .view-content {
      padding: 15px;
      height: 100%;
      overflow-y: auto;
      background: var(--card-bg);
      display: none;
    }
    .view-content.active {
      display: block;
    }

    /* Job Panel Modal */
    #jobPanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.75);
      z-index: 100;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    .job-card {
      background: var(--card-bg);
      border-radius: 15px;
      width: 90%;
      max-width: 400px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      animation: fadeIn 0.3s ease-out;
      border: 4px solid var(--secondary);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    .job-card h2 {
      margin-top: 0;
      color: var(--secondary);
      text-align: center;
      font-size: 1.5rem;
    }
    #jobTimer {
      text-align: center;
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--danger);
      margin-bottom: 20px;
    }
    #jobInfo div {
      padding: 5px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px dashed #eee;
    }
    .job-info-label {
      font-weight: 500;
      color: var(--text-dark);
    }
    .job-info-value {
      font-weight: 700;
      color: var(--primary);
    }
    .job-actions {
      display: flex;
      gap: 15px;
      margin-top: 25px;
    }
    .job-actions button {
      flex: 1;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .job-actions button:active {
      transform: scale(0.98);
    }
    #acceptBtn {
      background: var(--success);
      color: white;
    }
    #rejectBtn {
      background: var(--danger);
      color: white;
    }

    /* Log Panel */
    #logView {
      background: var(--bg-light);
      font-family: 'Consolas', monospace;
      font-size: 0.8rem;
      padding: 10px;
      border-radius: 8px;
      white-space: pre-wrap;
      max-height: 100%;
      overflow-y: auto;
    }
    #logView .log-entry { margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px solid #ddd; }
    #logView .log-info { color: var(--secondary); }
    #logView .log-success { color: var(--success); font-weight: bold; }
    #logView .log-error { color: var(--danger); font-weight: bold; }
    #logView .log-warning { color: var(--warning); }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      margin-bottom: 15px;
      font-size: 0.9rem;
      padding: 10px;
      border-radius: 8px;
      background: var(--card-bg);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .status-indicator i { font-size: 1.2rem; }

    /* --- Chat View Styling --- */
    #chatView {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 0; 
    }
    .chat-status-indicator {
        padding: 15px;
        background: var(--card-bg);
        border-bottom: 1px solid #eee;
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        background: var(--bg-light);
    }
    .chat-input-area {
        display: flex;
        padding: 10px 15px;
        border-top: 1px solid #ddd;
        background: var(--card-bg);
    }
    #chatInput {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 20px;
        margin-right: 10px;
        font-size: 1rem;
        transition: border-color 0.2s;
    }
    #chatInput:focus {
        border-color: var(--secondary);
        outline: none;
    }
    #sendBtn {
        background: var(--secondary);
        color: white;
        border: none;
        border-radius: 20px;
        width: 45px;
        height: 45px;
        cursor: pointer;
        transition: background 0.2s;
    }
    #sendBtn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Message Bubble Styling */
    .message {
        display: flex;
        margin-bottom: 10px;
    }
    .message-content {
        padding: 10px 15px;
        border-radius: 18px;
        max-width: 75%;
        position: relative;
        font-size: 0.9rem;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    .message.driver {
        justify-content: flex-end;
        align-self: flex-end;
        width: 100%;
    }
    .message.driver .message-content {
        background: var(--secondary);
        color: var(--text-light);
        border-bottom-right-radius: 2px;
    }
    .message.other {
        justify-content: flex-start;
        align-self: flex-start;
        width: 100%;
    }
    .message.other .message-content {
        background: #e9ecef;
        color: var(--text-dark);
        border-bottom-left-radius: 2px;
    }
    .message-sender {
        font-size: 0.7rem;
        color: #ddd; /* Light color for driver sender in dark bubble */
        margin-bottom: 3px;
        display: block;
        font-weight: 500;
    }
    .message.other .message-sender {
        color: #777; /* Darker color for other sender in light bubble */
    }

  </style>
</head>
<body>

<div class="app-header">
  <div id="appTitleContainer">
    <h1>Black Cab Unite</h1>
    <div id="statusDisplay"><span class="status-dot offline" id="statusDot"></span><span id="currentStatusText">Offline</span></div>
  </div>
  <div class="menu-nav">
    <button class="nav-btn active" data-view="map"><i class="fa-solid fa-map-location-dot"></i> Map</button>
    <button class="nav-btn" data-view="jobs"><i class="fa-solid fa-list-check"></i> Jobs</button>
    <button class="nav-btn" data-view="chat"><i class="fa-solid fa-comment-dots"></i> Chat</button>
    <button class="nav-btn" data-view="log"><i class="fa-solid fa-list-ul"></i> Log</button>
  </div>
</div>

<!-- Status Dropdown (Hidden by default) -->
<div id="statusDropdown">
  <div class="status-option" data-status="active"><span class="status-dot active"></span>Active</div>
  <div class="status-option" data-status="idle"><span class="status-dot idle"></span>Idle</div>
  <div class="status-option" data-status="busy"><span class="status-dot busy"></span>Busy</div>
  <div class="status-option" id="logOffBtn"><span class="status-dot offline"></span>Log Off</div>
</div>

<div class="main-content">
  <div id="map" class="view-content active"></div>
  
  <div id="jobsView" class="view-content">
    <div class="status-indicator">
      <i class="fa-solid fa-taxi"></i>
      <span id="currentJobStatus">No Active Job</span>
    </div>
    <div style="font-size:1.1rem; font-weight:600; margin-bottom:10px; border-bottom: 2px solid #ccc; padding-bottom: 5px;">My Jobs History</div>
    <ul id="jobHistoryList" style="list-style:none; padding:0; margin:0;">
      <!-- Job items will be rendered here -->
    </ul>
  </div>

  <!-- NEW CHAT VIEW -->
  <div id="chatView" class="view-content">
    <div class="chat-status-indicator">
        <i class="fa-solid fa-comment-dots"></i>
        <span id="chatHeader">Driver Network Chat (Connecting...)</span>
    </div>
    <div id="messagesContainer" class="messages-container">
        <!-- Messages will appear here -->
        <div id="chatPlaceholder" style="text-align:center; padding: 20px; color:#999;">Start chatting with other drivers here!</div>
    </div>
    <div class="chat-input-area">
        <input type="text" id="chatInput" placeholder="Type message..." disabled />
        <button id="sendBtn" disabled><i class="fa-solid fa-paper-plane"></i></button>
    </div>
  </div>

  <div id="logView" class="view-content">
    <h3 style="margin-top:0; color:var(--secondary); font-size:1.2rem;">Activity Log</h3>
    <div id="logOutput"></div>
    <button class="nav-btn" style="background:#dc3545; color:white; margin-top:15px; width:100%;" onclick="clearLog()">Clear Log</button>
  </div>
</div>

<!-- Job Panel Modal -->
<div id="jobPanel">
  <div class="job-card">
    <h2>New Job Alert!</h2>
    <div id="jobTimer">Time left to accept: 30s</div>
    <div id="jobInfo">
      <!-- Job details will be injected here -->
    </div>
    <div class="job-actions">
      <button id="acceptBtn">Accept</button>
      <button id="rejectBtn">Reject</button>
    </div>
  </div>
</div>


<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
// === CONFIG ===
const DRIVER_ID = `driver-${Math.random().toString(36).substring(2, 8)}`;
const MAP_DEFAULT_COORDS = { lat: 52.407234, lng: -1.525504 };
const MAP_ZOOM = 15;
const FCM_VAPID_KEY = "BMl7GKaqVFHFCn3hkjtrgguYUIM87Hfqd4bbN5lzBiWSjUjEFC8ToIi947P3GqyYnZmaHOJtVjwRHcUcCmuLbow";
const FALLBACK_FIREBASE_CONFIG = {
  apiKey: "AIzaSyBq1aN-KRW7S243ef7lz7fnZmlBcuN1s", // Mocked key
  authDomain: "cabunite.firebaseapp.com",
  projectId: "cabunite",
  storageBucket: "cabunite.firebasestorage.app",
  messagingSenderId: "997924656033",
  appId: "1:997924656033:web:1552b9f26a1af0878eb1e0"
};

// === STATE & GLOBALS ===
let client = null;
let currentStatus = 'offline';
let currentJob = null;
let jobTimerInterval = null;
let wakeLock = null;
let currentView = 'map';
let jobHistory = JSON.parse(localStorage.getItem('jobHistory') || '[]');
let driverMarker = null;
let driverLocation = { lat: MAP_DEFAULT_COORDS.lat, lng: MAP_DEFAULT_COORDS.lng };
let fcmToken = null;
let isAuthReady = false;

// Firebase & Chat State
let db = null;
let auth = null;
let userId = null;
let chatUnsubscribe = null;
const DRIVER_ROLE = 'driver';

// Global object to hold DOM elements for easy access (el is now defined)
const el = {}; 

// Use mandatory global variables provided by the environment, with fallbacks
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : FALLBACK_FIREBASE_CONFIG;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;


// === FIREBASE SETUP ===

async function initFirebase() {
    try {
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        
        // Use setLogLevel('debug') for troubleshooting. Remove for production
        // setLogLevel('debug'); 

        // 1. Handle Authentication
        if (initialAuthToken) {
            await signInWithCustomToken(auth, initialAuthToken);
        } else {
            // Sign in anonymously if no token is provided
            await signInAnonymously(auth);
        }

        // 2. Set up Auth State Listener
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                logMsg(`üë§ Authenticated. User ID: ${userId}`, 'success');
                isAuthReady = true;
                connectMQTT(); // Connect MQTT only after authentication
                startGlobalChatListener(); // <--- START GLOBAL DRIVER CHAT HERE
            } else {
                userId = null;
                isAuthReady = true; // Still ready, but unauthenticated (anonymous fallback)
                logMsg('‚ö†Ô∏è Anonymous authentication failed or signed out.', 'warning');
            }
        });

    } catch (e) {
        logMsg(`‚ùå Firebase Init Error: ${e.message}`, 'error');
    }
}


// === CHAT FUNCTIONS ===

/**
 * Defines the public collection path for driver-to-driver communication.
 * Path: /artifacts/{appId}/public/data/driver_global_chat
 */
function getGlobalChatCollectionPath() {
    return `artifacts/${appId}/public/data/driver_global_chat`;
}

function renderMessage(message, isDriver) {
    const time = message.timestamp ? new Date(message.timestamp.seconds * 1000).toLocaleTimeString() : 'now';
    
    // Use a shortened version of the driver ID for identification in the global chat
    const senderIdShort = message.senderId ? message.senderId.substring(0, 6) : 'Unknown';
    const senderDisplay = isDriver ? 'You' : `Driver (${senderIdShort})`;

    const messageHtml = `
        <div class="message ${isDriver ? 'driver' : 'other'}">
            <div class="message-content">
                <span class="message-sender">${senderDisplay} - ${time}</span>
                ${message.text}
            </div>
        </div>
    `;
    el.messagesContainer.insertAdjacentHTML('beforeend', messageHtml);
}

function renderMessages(messages) {
    el.messagesContainer.innerHTML = ''; // Clear existing messages
    el.chatPlaceholder.style.display = messages.length === 0 ? 'block' : 'none';

    messages.forEach(msg => {
        const isDriver = msg.senderId === userId;
        renderMessage(msg, isDriver);
    });

    // Scroll to bottom
    el.messagesContainer.scrollTop = el.messagesContainer.scrollHeight;
}

/**
 * Starts the listener for the global driver chat.
 */
function startGlobalChatListener() {
    // 1. Stop previous listener if one exists
    if (chatUnsubscribe) {
        chatUnsubscribe();
        chatUnsubscribe = null;
    }

    if (!db || !isAuthReady || !userId) {
        el.chatHeader.textContent = 'Driver Network Chat (Logging in...)';
        el.chatInput.disabled = true;
        el.sendBtn.disabled = true;
        return; 
    }

    logMsg(`üí¨ Starting global chat listener.`, 'info');
    el.chatHeader.textContent = 'Driver Network Chat';
    el.chatInput.disabled = false;
    el.sendBtn.disabled = false;
    el.chatPlaceholder.style.display = 'none';

    try {
        const chatRef = collection(db, getGlobalChatCollectionPath());
        // Order by timestamp to show the history correctly
        const q = query(chatRef, orderBy('timestamp', 'asc'));

        chatUnsubscribe = onSnapshot(q, (snapshot) => {
            const messages = [];
            snapshot.forEach(doc => {
                messages.push(doc.data());
            });
            renderMessages(messages);
        }, (error) => {
            logMsg(`‚ùå Chat Listener Error: ${error.message}`, 'error');
        });
    } catch (e) {
        logMsg(`‚ùå Chat Query Setup Error: ${e.message}`, 'error');
    }
}

async function sendMessage() {
    const text = el.chatInput.value.trim();
    // Check only for text, db, and userId (no longer depends on currentJob)
    if (!text || !db || !userId) return; 

    el.chatInput.value = ''; // Clear input immediately
    el.sendBtn.disabled = true; // Disable to prevent double send

    const messageData = {
        text: text,
        senderId: userId,
        senderRole: DRIVER_ROLE,
        timestamp: serverTimestamp() 
    };

    try {
        const chatRef = collection(db, getGlobalChatCollectionPath()); // Use global path
        await addDoc(chatRef, messageData);
        logMsg('üí¨ Message sent successfully.', 'info');
    } catch (e) {
        logMsg(`‚ùå Failed to send message: ${e.message}`, 'error');
    } finally {
        el.sendBtn.disabled = false;
    }
}


// === LOGGING ===
function logMsg(msg, type = 'info') {
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    const dateStr = now.toLocaleDateString();
    
    let typeClass = 'log-info';
    if (type === 'success') typeClass = 'log-success';
    else if (type === 'error') typeClass = 'log-error';
    else if (type === 'warning') typeClass = 'log-warning';
    
    const entry = `[${dateStr} ${timeStr}] <span class="${typeClass}">${msg}</span>`;
    
    // Update local storage log
    const logs = (localStorage.getItem('activityLog') || '') + entry + '\n';
    localStorage.setItem('activityLog', logs);
    
    // Update DOM log (only showing recent entries for performance)
    if (el.logOutput) { // Check if el.logOutput is available (it should be after initApp runs)
        el.logOutput.innerHTML = logs
            .split('\n')
            .filter(line => line.trim())
            .slice(-50) // Keep the last 50 entries
            .map(line => `<div class="log-entry">${line}</div>`)
            .join('');
        el.logOutput.scrollTop = el.logOutput.scrollHeight;
    }
}

function clearLog() {
    localStorage.removeItem('activityLog');
    if (el.logOutput) el.logOutput.textContent = '';
}

// === VIEW SWITCHING (Fix for 'classList' error) ===
function renderCurrentView() {
    const views = document.querySelectorAll('.view-content');
    
    // Determine the ID of the view container to be active
    let targetViewId;
    if (currentView === 'map') {
        targetViewId = 'map';
    } else {
        targetViewId = currentView + 'View'; // e.g., 'jobs' -> 'jobsView'
    }

    views.forEach(view => {
        // This check ensures we only try to access classList on a valid DOM element
        if (view) { 
            if (view.id === targetViewId) {
                view.classList.add('active');
                if (view.id === 'map' && map) {
                    map.invalidateSize();
                }
            } else {
                view.classList.remove('active');
            }
        }
    });
}

// === MAP ===
const map = L.map('map');
let locationWatcherId = null;

function initMapImmediately() {
    map.setView([MAP_DEFAULT_COORDS.lat, MAP_DEFAULT_COORDS.lng], MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    driverMarker = L.marker([MAP_DEFAULT_COORDS.lat, MAP_DEFAULT_COORDS.lng], {
        icon: L.divIcon({
            className: 'driver-icon',
            html: `<div style="background:var(--primary);color:white;width:30px;height:30px;border-radius:50%;border:4px solid white;box-shadow:0 0 8px rgba(0,0,0,0.4);display:flex;align-items:center;justify-content:center;font-weight:bold;"><i class="fa-solid fa-taxi"></i></div>`,
            iconSize: [38, 38],
            iconAnchor: [19, 19]
        })
    }).addTo(map);

    // Initial position marker update
    updateLocationMarker(MAP_DEFAULT_COORDS.lat, MAP_DEFAULT_COORDS.lng);
}

function updateLocationMarker(lat, lng) {
    driverLocation = { lat, lng };
    driverMarker.setLatLng([lat, lng]);
    map.panTo([lat, lng], { animate: true });
}

// === GEOLOCATION & PRESENCE ===
function startGeolocation() {
    if (!navigator.geolocation) {
        logMsg("‚ùå Geolocation not supported", 'error');
        return;
    }

    const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
    locationWatcherId = navigator.geolocation.watchPosition(
        (position) => {
            const { latitude, longitude } = position.coords;
            updateLocationMarker(latitude, longitude);
            publishLocation({ lat: latitude, lng: longitude });
            logMsg(`üì° Location updated: ${latitude.toFixed(4)}, ${longitude.toFixed(4)}`, 'info');
        },
        (error) => {
            logMsg(`‚ùå Geolocation error: ${error.message}`, 'error');
        },
        options
    );
    logMsg("üìç Location tracking started", 'success');
}

function stopGeolocation() {
    if (locationWatcherId !== null) {
        navigator.geolocation.clearWatch(locationWatcherId);
        locationWatcherId = null;
        logMsg("üõë Location tracking stopped", 'warning');
    }
}

function setDriverPresence(status) {
    if (status === currentStatus) return;

    if (status === 'active' || status === 'idle' || status === 'busy') {
        if (currentStatus === 'offline' && userId) startGeolocation();
        if (currentJob && currentJob.status === 'allocated' && status !== 'busy') {
             // Cannot change status if a job is in progress, unless setting to busy
             logMsg(`‚ö†Ô∏è Cannot change status while job ${currentJob.job} is active.`, 'warning');
             return;
        }
    } else if (status === 'offline') {
        stopGeolocation();
        driverMarker.setOpacity(0.3);
    }
    
    currentStatus = status;
    
    // Update UI
    el.currentStatusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
    el.statusDot.className = `status-dot ${status}`;
    
    // Publish status
    if (client) publishStatus(status);
    logMsg(`üîÑ Status changed to: ${status}`, 'info');
}

function handleLogOff() {
    if (currentJob && currentJob.status === 'allocated') {
        if (!window.confirm('You must complete or abandon your current job before logging off. Are you sure you want to log off and abandon the job?')) {
            return;
        }
        if (client) {
             client.publish(`jobs/${currentJob.job}/status`, JSON.stringify({
                job: currentJob.job,
                driver: DRIVER_ID,
                status: 'abandoned',
                ts: Date.now()
            }));
        }
    }
    setDriverPresence('offline');
    if (auth) signOut(auth);
    if (chatUnsubscribe) {
      chatUnsubscribe(); // Stop chat listener on log off
      chatUnsubscribe = null;
    }
}

// === MQTT ===
function connectMQTT() {
    if (client) return; 

    client = mqtt.connect('wss://broker.hivemq.com:8884/mqtt', { 
        connectTimeout: 4000, 
        reconnectPeriod: 2000,
        clientId: DRIVER_ID 
    });

    client.on('connect', () => {
        logMsg('‚úÖ Connected to MQTT', 'success');
        
        // Subscribe to job requests and status updates
        client.subscribe(`jobs/${DRIVER_ID}/request`);
        client.subscribe(`jobs/${DRIVER_ID}/allocated`);
        client.subscribe(`jobs/+/status`); 
        
        // Publish current state after connection
        if (currentStatus !== 'offline') {
            publishStatus(currentStatus);
            publishLocation(driverLocation);
        }
        if (fcmToken) publishFcmToken();
    });

    client.on('message', (topic, message) => {
        try {
            const payload = JSON.parse(message.toString());
            const jobId = payload.job;

            if (topic.endsWith('/request')) {
                // NEW JOB ALERT (Bidding phase)
                if (currentStatus !== 'active' && currentStatus !== 'idle') {
                    logMsg(`Job ${jobId} ignored (Status: ${currentStatus})`, 'warning');
                    return;
                }
                if (currentJob && currentJob.status === 'allocated') {
                    logMsg(`Job ${jobId} ignored (Already busy with ${currentJob.job})`, 'warning');
                    return;
                }
                showJobPanel(payload);
                logMsg(`üîî New job alert: ${jobId}`, 'info');
            } else if (topic.startsWith('jobs/') && topic.endsWith('/status')) {
                // Job Status Updates (e.g., allocated, completed, relisted)
                if (jobId) {
                    const status = payload.status;

                    if (status === 'allocated' && payload.driver === DRIVER_ID) {
                        currentJob = { ...payload, status: 'allocated' };
                        el.jobPanel.style.display = 'none';
                        if (jobTimerInterval) clearInterval(jobTimerInterval);
                        logMsg(`üèÜ Job ${jobId} allocated to you!`, 'success');
                        el.currentJobStatus.innerHTML = `<i class="fa-solid fa-bell-concierge"></i> Job **${jobId}** allocated.`;
                        updateJobHistory();
                        // listenToJobChat(jobId); // Removed job-chat activation
                        setDriverPresence('busy'); // Automatically set to busy
                    } else if (status === 'completed' || status === 'abandoned') {
                        if (currentJob && currentJob.job === jobId) {
                            currentJob = null; 
                            logMsg(`Job ${jobId} marked as ${status}.`, 'info');
                            el.currentJobStatus.innerHTML = `<i class="fa-solid fa-check"></i> No Active Job`;
                            updateJobHistory();
                            setDriverPresence('idle'); // Back to idle
                            // listenToJobChat(null); // Removed job-chat deactivation
                        }
                    } else if (status === 'relisted') {
                         if (currentJob && currentJob.job === jobId) {
                            currentJob = null; 
                            logMsg(`Job ${jobId} relisted by dispatcher/expired.`, 'warning');
                            el.jobPanel.style.display = 'none';
                            if (jobTimerInterval) clearInterval(jobTimerInterval);
                            el.currentJobStatus.innerHTML = `<i class="fa-solid fa-check"></i> No Active Job`;
                            // listenToJobChat(null); // Removed job-chat deactivation
                         }
                    }
                }
            }

        } catch(e) {
            logMsg(`‚ùå MQTT Message Error: ${e.message}`, 'error');
        }
    });

    client.on('error', (err) => {
        logMsg(`‚ùå MQTT connection error: ${err.message}`, 'error');
    });

    client.on('close', () => {
        logMsg('üîå MQTT disconnected', 'warning');
    });
}

function publishStatus(status) {
    if (client && client.connected) {
        client.publish(`drivers/${DRIVER_ID}/status`, JSON.stringify({ driverId: DRIVER_ID, status: status }));
    }
}

function publishLocation(location) {
    if (client && client.connected) {
        client.publish(`drivers/${DRIVER_ID}/location`, JSON.stringify({ 
            lat: location.lat, 
            lng: location.lng, 
            status: currentStatus, 
            ts: Date.now() 
        }));
    }
}

function publishFcmToken() {
    if (client && client.connected && fcmToken) {
         client.publish(`drivers/${DRIVER_ID}/fcm_token`, JSON.stringify({ 
            driverId: DRIVER_ID, 
            token: fcmToken, 
            ts: Date.now() 
        }));
    }
}

// === JOB UI & LOGIC ===

function promptForVoiceResponse() {
    if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance("New job alert. Respond now.");
        utterance.rate = 1.1;
        utterance.volume = 1;
        speechSynthesis.speak(utterance);
    }
}

function showJobPanel(job) {
  if (!job) return;
  currentJob = job;
  currentJob.status = 'bidding'; 
  
  el.jobPanel.style.display = 'flex'; 

  const jobInfo = el.jobInfo;
  jobInfo.innerHTML = `
    <div class="job-info-label">Job ID:</div>
    <div class="job-info-value">${job.job || 'N/A'}</div>

    <div class="job-info-label" style="margin-top:10px;">Pickup Location:</div>
    <div class="job-info-value">${job.pubName || 'N/A'}</div>
    
    <div class="job-info-label" style="margin-top:10px;">Customer:</div>
    <div class="job-info-value">${job.customerName || 'N/A'}</div>

    <div class="job-info-label" style="margin-top:10px;">Phone:</div>
    <div class="job-info-value">${job.customerPhone || 'N/A'}</div>
  `; 
  
  const jobTimerEl = document.getElementById('jobTimer');
  jobTimerEl.style.display = 'block';
  
  let timeLeft = 30; 
  if (jobTimerInterval) clearInterval(jobTimerInterval);

  const updateTimer = () => {
    jobTimerEl.textContent = `Time left to accept: ${timeLeft}s`;
    if (timeLeft <= 0) {
      clearInterval(jobTimerInterval);
      el.jobPanel.style.display = 'none';
      logMsg(`Job ${currentJob.job} time expired.`, 'warning');
      currentJob = null;
    }
    timeLeft--;
  };

  updateTimer();
  jobTimerInterval = setInterval(updateTimer, 1000);
  promptForVoiceResponse();
}

function respondToJob(accepted) {
    if (!currentJob) return;

    if (jobTimerInterval) clearInterval(jobTimerInterval);
    el.jobPanel.style.display = 'none';
    
    const responseStatus = accepted ? 'bid' : 'rejected';
    
    if (client && client.connected) {
        client.publish(`jobs/${currentJob.job}/response`, JSON.stringify({
            job: currentJob.job,
            driver: DRIVER_ID,
            status: responseStatus,
            lat: driverLocation.lat,
            lng: driverLocation.lng,
            ts: Date.now()
        }));
        logMsg(`Response sent for job ${currentJob.job}: ${responseStatus}`, 'info');

        // If rejected, clear job immediately. If bid, wait for 'allocated' status.
        if (!accepted) {
            currentJob = null;
        }
    } else {
        logMsg('‚ùå Cannot respond, MQTT disconnected.', 'error');
        currentJob = null;
    }
}

function updateJobHistory() {
    if (currentJob && currentJob.status === 'allocated') {
        // Find if job already exists in history
        const existingIndex = jobHistory.findIndex(j => j.job === currentJob.job);
        
        const historyItem = {
            job: currentJob.job,
            pickup: currentJob.pubName,
            customer: currentJob.customerName,
            status: currentJob.status,
            bookedAt: new Date().toLocaleString()
        };

        if (existingIndex !== -1) {
             jobHistory[existingIndex] = historyItem;
        } else {
             jobHistory.unshift(historyItem);
        }

        // Keep a manageable history size
        jobHistory = jobHistory.slice(0, 10);
        localStorage.setItem('jobHistory', JSON.stringify(jobHistory));
    }

    // Render the list
    el.jobHistoryList.innerHTML = jobHistory.map(job => `
        <li style="padding: 10px; border-bottom: 1px solid #ddd; display: flex; justify-content: space-between; align-items: center; background: ${job.status === 'allocated' ? '#e6f7ff' : '#fff'}; border-radius: 5px; margin-bottom: 5px;">
            <div>
                <strong>${job.job}</strong> - ${job.customer}
                <br><small style="color: #666;">Pickup: ${job.pickup}</small>
            </div>
            <span style="font-weight: 700; color: ${job.status === 'allocated' ? 'var(--secondary)' : '#999'};">
                ${job.status.charAt(0).toUpperCase() + job.status.slice(1)}
            </span>
        </li>
    `).join('');
}


// === INIT & EVENT LISTENERS ===
function initApp() {
    // 0. Initialize the 'el' object with all necessary DOM elements
    el.currentStatusText = document.getElementById('currentStatusText');
    el.statusDot = document.getElementById('statusDot');
    el.logOutput = document.getElementById('logOutput');
    el.jobHistoryList = document.getElementById('jobHistoryList');
    el.jobPanel = document.getElementById('jobPanel');
    el.jobInfo = document.getElementById('jobInfo');
    el.currentJobStatus = document.getElementById('currentJobStatus');
    el.statusDropdown = document.getElementById('statusDropdown');
    el.logOffBtn = document.getElementById('logOffBtn');
    el.appTitleContainer = document.getElementById('appTitleContainer');
    
    // Chat Elements
    el.messagesContainer = document.getElementById('messagesContainer');
    el.chatPlaceholder = document.getElementById('chatPlaceholder');
    el.chatHeader = document.getElementById('chatHeader');
    el.chatInput = document.getElementById('chatInput');
    el.sendBtn = document.getElementById('sendBtn');
    el.acceptBtn = document.getElementById('acceptBtn');
    el.rejectBtn = document.getElementById('rejectBtn');


    // 1. Map Initialization
    initMapImmediately();

    // 2. Firebase Initialization (includes Auth and MQTT connect)
    initFirebase();

    // 3. Load Log History
    const savedLog = localStorage.getItem('activityLog') || '';
    if (savedLog) {
        el.logOutput.innerHTML = savedLog
            .split('\n')
            .filter(line => line.trim())
            .slice(-50)
            .map(line => `<div class="log-entry">${line}</div>`)
            .join('');
        el.logOutput.scrollTop = el.logOutput.scrollHeight;
    }

    // 4. Load Job History
    updateJobHistory();
    
    // 5. Setup Event Listeners

    // Navigation buttons
    const menuNavBtns = document.querySelectorAll('.nav-btn');
    menuNavBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        menuNavBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;
        renderCurrentView();
      });
    });

    // Job Panel actions
    el.acceptBtn.addEventListener('click', () => respondToJob(true));
    el.rejectBtn.addEventListener('click', () => respondToJob(false));
    
    // Status dropdown toggle
    el.appTitleContainer.addEventListener('click', (e) => {
      e.stopPropagation();
      el.statusDropdown.style.display = el.statusDropdown.style.display === 'flex' ? 'none' : 'flex';
    });
    
    // Status options
    document.querySelectorAll('.status-option').forEach(option => {
      option.addEventListener('click', () => {
        const newStatus = option.dataset.status;
        if (newStatus) setDriverPresence(newStatus);
        el.statusDropdown.style.display = 'none';
      });
    });
    el.logOffBtn.addEventListener('click', handleLogOff);
    document.addEventListener('click', () => {
      el.statusDropdown.style.display = 'none';
    });
    el.statusDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Chat functionality listeners
    el.sendBtn.addEventListener('click', sendMessage);
    el.chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendMessage();
        }
    });
}

// Start the app when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', initApp);

</script>

      font-family:system-ui, -apple-system, "Segoe UI", sans-serif; 
      background:#f7fafc; 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      overflow:hidden;
    }
    #map { 
      flex:1; 
      width:100%;
      height:100%;
      z-index:1;
    }
    /* Black Cab Unite Header Banner */
    #headerBanner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: #000;
      color: #FFD700;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    #appTitleContainer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #appTitle {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    #appTitle::before {
      content: "üöï";
      font-size: 20px;
    }
    #statusCaption {
      font-size: 12px;
      color: #FFD700;
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .status-available .status-dot { background: #28a745; }
    .status-busy .status-dot { background: #ffc107; }
    .status-offline .status-dot { background: #dc3545; }
    #menuBtn {
      background: #FFD700;
      color: #000;
      border: none;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
      z-index: 1002;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: transform 0.1s ease;
    }
    #menuBtn:active {
      transform: scale(0.95);
    }
    /* === PASSENGER PRESET POPUP === */
    #passengerPopup {
      display: none;
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 18px 20px;
      border-radius: 16px;
      font-size: 16px;
      max-width: 300px;
      text-align: center;
      z-index: 3000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .replyBtn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      flex: 1;
      margin: 0 4px;
    }
    .replyBtn:nth-child(2) {
      background: #1f6feb;
    }
    /* Status bar at bottom */
    #status { 
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 16px;
      border-radius: 24px;
      font-size: 14px;
      color: #333;
      z-index: 1000;
      text-align: center;
      max-width: 90%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 600;
    }
    .gps-source {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .gps-gps { background: #28a745; }
    .gps-network { background: #17a2b8; }
    .gps-poor { background: #ffc107; }
    /* Job panel */
    #jobPanel { 
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 20px;
      border-top: 2px solid #eee;
      z-index: 1000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
      display: none;
    }
    #jobPanel h2 { 
      margin: 0 0 16px 0; 
      font-size: 20px; 
      color: #1f6feb;
      text-align: center;
    }
    #jobInfo { 
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 24px;
      font-size: 15px;
      line-height: 1.5;
    }
    .job-info-label {
      font-weight: 600;
      color: #495057;
      margin-bottom: 4px;
    }
    .job-info-value {
      font-size: 16px;
      color: #212529;
    }
    #jobTimer {
      margin-top: 12px;
      font-size: 14px;
      color: #dc3545;
      font-weight: bold;
      display: none;
    }
    .job-actions {
      display: flex;
      gap: 16px;
    }
    .job-btn {
      flex: 1;
      padding: 18px 12px;
      font-size: 18px;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 700;
      min-height: 56px;
    }
    .accept-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
    }
    .reject-btn {
      background: linear-gradient(135deg, #dc3545, #e83e8c);
      color: white;
    }
    /* Glowing Mic Indicator */
    #micIndicator {
      text-align: center;
      margin: 16px 0;
      display: none;
    }
    .mic-icon {
      width: 48px;
      height: 48px;
      background: #1f6feb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 12px #1f6feb;
      animation: micGlow 1.5s infinite alternate;
    }
    @keyframes micGlow {
      from { box-shadow: 0 0 12px #1f6feb; }
      to { box-shadow: 0 0 24px #1f6feb, 0 0 32px #1f6feb; }
    }
    .mic-label {
      font-size: 13px;
      color: #555;
      margin-top: 8px;
    }
    /* Driver icons */
    .other-driver-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 10px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    /* Loading overlay */
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
      color: white;
      font-size: 18px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Main Menu Panel */
    #menuPanel {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70vh;
      background: white;
      display: none;
      flex-direction: column;
      z-index: 2000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    #menuPanel.active {
      display: flex;
      transform: translateY(0);
    }
    #menuNav {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #eee;
    }
    .menu-nav-btn {
      flex: 1;
      background: transparent;
      border: none;
      padding: 16px 0;
      font-weight: 600;
      font-size: 15px;
      color: #666;
      cursor: pointer;
    }
    .menu-nav-btn.active {
      color: #1f6feb;
      background: #e8f0fe;
      border-bottom: 3px solid #1f6feb;
    }
    #menuContent {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .current-job-info {
      padding: 20px;
      background: #e8f5e8;
      border-radius: 12px;
      margin-bottom: 20px;
      border-left: 4px solid #28a745;
    }
    .job-detail {
      margin-bottom: 12px;
    }
    .job-label {
      font-weight: 700;
      color: #1f6feb;
      font-size: 15px;
      margin-bottom: 4px;
    }
    .job-value {
      font-size: 17px;
      color: #333;
      word-break: break-word;
    }
    .no-current-job {
      text-align: center;
      padding: 50px 20px;
      color: #666;
    }
    .no-current-job .icon {
      font-size: 60px;
      margin-bottom: 20px;
      opacity: 0.7;
    }
    .job-item {
      padding: 16px;
      border: 1px solid #eee;
      border-radius: 12px;
      margin-bottom: 12px;
      background: #f9f9f9;
      position: relative;
      overflow: hidden;
    }
    .job-item.allocated { border-left: 4px solid #28a745; background: #e8f5e8; }
    .job-item.processing, .job-item.bidding { border-left: 4px solid #1f6feb; background: #e8f0fe; }
    .job-item.completed { border-left: 4px solid #6c757d; background: #f8f9fa; }
    .job-item.lost, .job-item.rejected, .job-item.expired { border-left: 4px solid #dc3545; background: #f8d7da; }
    .job-item.queued { border-left: 4px solid #ffc107; background: #fff8e1; }
    .job-id { font-weight: 700; color: #1f6feb; margin-bottom: 6px; font-size: 16px; }
    .job-pub { font-size: 14px; color: #666; margin-bottom: 6px; }
    .job-phone { font-size: 15px; color: #333; margin-bottom: 6px; }
    .job-status {
      font-size: 12px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 6px;
    }
    .status-processing, .status-bidding { background: #d1e7ff; color: #084298; }
    .status-allocated { background: #d1e7dd; color: #0f5132; }
    .status-completed { background: #e2e3e5; color: #41464b; }
    .status-lost, .status-rejected, .status-expired { background: #f8d7da; color: #842029; }
    .status-queued { background: #fff3cd; color: #856404; }
    /* Swipe-to-delete with trash icon */
    .job-item::after {
      content: "üóëÔ∏è";
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      background: #dc3545;
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .job-item.swiping::after {
      opacity: 1;
    }
    #chatMessages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .message {
      max-width: 85%;
      padding: 14px 16px;
      border-radius: 20px;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
    }
    .received { background: #e9ecef; align-self: flex-start; border-bottom-left-radius: 6px; }
    .sent { background: #000; color: white; align-self: flex-end; border-bottom-right-radius: 6px; }
    .message-info {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
    }
    #chatInputContainer {
      display: flex;
      padding: 12px;
      background: white;
      border-top: 1px solid #eee;
    }
    #chatInput {
      flex: 1;
      padding: 14px;
      border: 2px solid #ddd;
      border-radius: 24px;
      font-size: 16px;
      outline: none;
    }
    #chatInput:focus {
      border-color: #1f6feb;
      box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.2);
    }
    #sendBtn {
      background: #000;
      color: #FFD700;
      border: none;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      margin-left: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #chatList {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .contact-item {
      padding: 16px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s;
    }
    .contact-item:hover {
      background: #f8f9fa;
    }
    .contact-name {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 4px;
    }
    .contact-status {
      font-size: 13px;
      color: #6c757d;
    }
    .contact-badge {
      background: #28a745;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    .offline { background: #6c757d; }
    .unread-badge {
      background: #FFD700;
      color: #000;
      border-radius: 12px;
      padding: 4px 8px;
      font-size: 12px;
      margin-left: 8px;
      font-weight: 700;
    }
    .settings-group {
      margin-bottom: 24px;
    }
    .settings-label {
      font-weight: 700;
      margin-bottom: 12px;
      color: #333;
      font-size: 16px;
    }
    .settings-input {
      width: 100%;
      padding: 14px;
      border: 2px solid #ccc;
      border-radius: 12px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .settings-input:focus {
      border-color: #1f6feb;
      outline: none;
    }
    .settings-btn {
      background: #1f6feb;
      color: white;
      border: none;
      padding: 16px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      margin-top: 12px;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(31, 111, 235, 0.3);
    }
    .settings-btn:hover {
      background: #1958c4;
      box-shadow: 0 6px 16px rgba(31, 111, 235, 0.4);
    }
    .settings-info {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      font-size: 14px;
      color: #666;
      line-height: 1.5;
    }
    /* Enhanced Taxi Marker */
    .taxi-marker {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="headerBanner">
    <div id="appTitleContainer">
      <div id="appTitle">Black Cab Unite v7.0</div>
      <div id="statusCaption" class="status-available">
        <span class="status-dot"></span> Available
      </div>
    </div>
    <button id="menuBtn">‚ò∞</button>
  </div>
  <div id="statusDropdown" style="
    position: absolute;
    top: 52px;
    left: 16px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1003;
    display: none;
    flex-direction: column;
    min-width: 180px;
  ">
    <div class="status-option" data-status="available" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#28a745; width:12px; height:12px; border-radius:50%;"></span> Available
    </div>
    <div class="status-option" data-status="busy" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#ffc107; width:12px; height:12px; border-radius:50%;"></span> Busy
    </div>
    <div class="status-option" data-status="offline" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#dc3545; width:12px; height:12px; border-radius:50%;"></span> Offline
    </div>
    <div id="logOffBtn" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px; border-top:1px solid #eee; color:#dc3545; font-weight:bold;">
      <span>üö™</span> Log Off
    </div>
  </div>
  <div id="status">Initializing...</div>
  <div id="jobPanel">
    <h2>üöï New Job Request</h2>
    <div id="jobInfo">
      <div class="job-info-label">Pickup Location</div>
      <div class="job-info-value" id="pickupLocation">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Name</div>
      <div class="job-info-value" id="customerName">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Phone</div>
      <div class="job-info-value" id="customerPhone">Loading...</div>
      <div id="jobTimer">‚è≥ Expires in: <span id="timerSeconds">30</span>s</div>
    </div>
    <div id="micIndicator">
      <div class="mic-icon">üé§</div>
      <div class="mic-label">Say ‚Äúaccept‚Äù or ‚Äúreject‚Äù</div>
    </div>
    <div class="job-actions">
      <button class="job-btn accept-btn" id="acceptBtn">‚úÖ ACCEPT JOB</button>
      <button class="job-btn reject-btn" id="rejectBtn">‚ùå REJECT</button>
    </div>
  </div>
  <div id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div>Loading map...</div>
  </div>
  <div id="menuPanel">
    <div id="menuNav">
      <button class="menu-nav-btn active" data-view="currentJob">üìç Current Job</button>
      <button class="menu-nav-btn" data-view="jobHistory">üìã Job History</button>
      <button class="menu-nav-btn" data-view="chat">üí¨ Chats</button>
      <button class="menu-nav-btn" data-view="settings">‚öôÔ∏è Settings</button>
    </div>
    <div id="menuContent"></div>
  </div>
  <div id="jobWonModal" style="
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  ">
    <div style="
      background: white;
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 320px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    ">
      <div style="font-size: 60px; margin-bottom: 16px;">üéâ</div>
      <h2 style="margin: 0 0 12px; color: #1f6feb;">You Won the Job!</h2>
      <p style="margin: 0 0 24px; color: #555;">Get ready to pick up the customer.</p>
      <button id="closeJobWonModal" style="
        background: #1f6feb;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 12px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
      ">Close</button>
    </div>
  </div>
  <div id="passengerPopup">
    <div id="passengerPopupMsg">Passenger message...</div>
    <div style="display:flex; justify-content:center; gap:10px; margin-top:12px;">
      <button id="presetReply1" class="replyBtn">On my way</button>
      <button id="presetReply2" class="replyBtn">Arrived</button>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script>
  // ===== FIREBASE INIT =====
  const firebaseConfig = {
    apiKey: "AIzaSyBq1aN-KRtRW7S243ef7lz7fnZmlBcuN1s",
    authDomain: "cabunite.firebaseapp.com",
    projectId: "cabunite",
    storageBucket: "cabunite.firebasestorage.app",
    messagingSenderId: "997924656033",
    appId: "1:997924656033:web:1552b9f26a1af0878eb1e0"
  };
  firebase.initializeApp(firebaseConfig);
  const messaging = firebase.messaging();

  messaging.onMessage((payload) => {
    console.log("üì≤ Foreground message received:", payload);
    if (Notification.permission === 'granted') {
      new Notification(payload.notification?.title || "Taxi Update", {
        body: payload.notification?.body || "You have a new message",
        icon: payload.notification?.icon || '/blackcabunite/icon-192.png'
      });
    }
  });

  // ‚úÖ GLOBAL fcmToken
  let fcmToken = null;

  document.addEventListener('DOMContentLoaded', () => {
    // ===== Driver Registration =====
    let DRIVER_ID = localStorage.getItem('driver_id');
    function validateDriverId(id) {
      if (!id) return false;
      return /^[a-zA-Z0-9_-]+$/.test(id);
    }
    if(!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
      while (!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
        DRIVER_ID = prompt("Enter your driver name or ID (letters, numbers, hyphens only):");
        if (DRIVER_ID === null) {
          DRIVER_ID = 'driver-' + Math.random().toString(36).substr(2, 8);
          break;
        }
      }
      localStorage.setItem('driver_id', DRIVER_ID);
    }

    // ===== FCM FUNCTIONS =====
    async function requestFCMToken() {
      try {
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
          console.warn('‚ö†Ô∏è Notification permission denied');
          return null;
        }

        const registration = await navigator.serviceWorker.register(
          '/blackcabunite/firebase-messaging-sw.js',
          { scope: '/blackcabunite/' }
        );

        // ‚úÖ Use GLOBAL fcmToken
        fcmToken = await messaging.getToken({
          vapidKey: "BJzV8Vx2sDvF6u9vGqK7vV5vD0U6X1aB5e4R3cN2mL1kJ0hI9gF8dC7bA6yZ5xW4vU3tS2rQ1pO0nM",
          serviceWorkerRegistration: registration
        });

        if (fcmToken) {
          console.log('‚úÖ FCM Token obtained');
          publishFcmToken(); // Safe: checks MQTT connection
        } else {
          console.warn('‚ö†Ô∏è No FCM token generated');
        }
        return fcmToken;
      } catch (err) {
        console.error('‚ùå FCM setup failed:', err);
        return null;
      }
    }

    function publishFcmToken() {
      if (!client?.connected) {
        console.log("‚è≥ MQTT not connected ‚Äî will retry on connect");
        return;
      }
      if (!fcmToken || !DRIVER_ID) {
        console.warn("‚ö†Ô∏è Missing FCM token or DRIVER_ID");
        return;
      }
      const payload = {
        driver: DRIVER_ID,
        fcmToken: fcmToken,
        ts: Date.now()
      };
      client.publish(`drivers/${DRIVER_ID}/fcm`, JSON.stringify(payload));
      console.log("üì§ Published FCM token via MQTT");
    }

    // ‚úÖ CALL FCM INIT AFTER DRIVER_ID IS SET
    if ('serviceWorker' in navigator && Notification.permission !== 'denied') {
      requestFCMToken();
    }

    // ===== Global State Variables and Constants =====
    let driverPresence = localStorage.getItem('driver_presence') || 'available';
    let ttsInitialized = false;
    function initTTS() {
      if (ttsInitialized || !('speechSynthesis' in window)) return;
      const utterance = new SpeechSynthesisUtterance('');
      utterance.volume = 0;
      speechSynthesis.speak(utterance);
      ttsInitialized = true;
    }
    document.body.addEventListener('click', initTTS, { once: true });
    document.body.addEventListener('touchstart', initTTS, { once: true });

    const MQTT_BROKER = "wss://broker.hivemq.com:8884/mqtt";
    const REQUEST_TOPIC = "pubs/requests/+";
    const LOCATION_TOPIC = `drivers/${DRIVER_ID}/location`;
    const DRIVERS_LOCATION_TOPIC = "drivers/+/location";
    const CHAT_GROUP_TOPIC = "chat/group";
    const JOB_RESULT_TOPIC = `jobs/+/result/${DRIVER_ID}`;

    // ===== PASSENGER PRESET HANDLING =====
    function handlePassengerPreset(data) {
      console.log("üí¨ Passenger preset received:", data);
      const preset = data?.presetType || "Unknown";
      const passengerMsg =
        preset === "where_are_you" ? "Passenger asks: Where are you?" :
        preset === "cancel_ride" ? "Passenger wants to cancel the ride." :
        preset === "call_driver" ? "Passenger is trying to call you." :
        `Passenger message: ${preset}`;

      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(passengerMsg);
        utterance.lang = 'en-GB';
        utterance.rate = 1;
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
      }
      showPassengerPopup(passengerMsg, data);
    }

    function showPassengerPopup(msg, data) {
      const popup = document.getElementById('passengerPopup');
      const msgEl = document.getElementById('passengerPopupMsg');
      msgEl.textContent = msg;
      popup.style.display = 'block';

      // Auto-hide popup after 15 seconds
      setTimeout(() => { popup.style.display = 'none'; }, 15000);

      document.getElementById('presetReply1').onclick = () => sendPresetReply('on_my_way', data);
      document.getElementById('presetReply2').onclick = () => sendPresetReply('arrived', data);
    }

    function sendPresetReply(type, data) {
      const payload = {
        type: 'driver_preset_reply',
        replyType: type,
        driverId: DRIVER_ID,
        jobId: data?.jobId || null,
        timestamp: new Date().toISOString()
      };
      client.publish('server/preset_replies', JSON.stringify(payload));
      document.getElementById('passengerPopup').style.display = 'none';
    }

    // ===== DEDUPLICATION & STATE MANAGEMENT HELPER =====
    function dedupeJobs(jobs) {
      const seen = new Set();
      return jobs.filter(job => {
        if (seen.has(job.job)) return false;
        seen.add(job.job);
        return true;
      });
    }
    function savePendingJobs() {
      localStorage.setItem(`pending_jobs_${DRIVER_ID}`, JSON.stringify(pendingJobs));
    }

    // Load and dedupe jobs
    let driverJobs = dedupeJobs(JSON.parse(localStorage.getItem(`driver_jobs_${DRIVER_ID}`)) || []);
    let pendingJobs = dedupeJobs(JSON.parse(localStorage.getItem(`pending_jobs_${DRIVER_ID}`)) || []);
    let driverCoords = null;
    let map = null;
    let driverMarker = null;
    let pickupMarker = null;
    let routeLine = null;
    let client = null;
    let isMenuOpen = false;
    let currentView = 'currentJob';
    let gpsWatchId = null;
    let wakeLock = null;
    const otherDrivers = {};
    const driverStatus = {};
    const chatMessages = { group: JSON.parse(localStorage.getItem(`chat_group_${DRIVER_ID}`)) || [] };
    const unreadCounts = { group: 0 };
    let maxRadius = parseFloat(localStorage.getItem('max_radius_km') || '10');
    let isJobActive = false;
    let currentChat = 'group';
    let jobTimerInterval = null;
    let jobWakeLock = null;

    const statusEl = document.getElementById('status');
    const jobPanel = document.getElementById('jobPanel');
    const pickupLocation = document.getElementById('pickupLocation');
    const customerName = document.getElementById('customerName');
    const customerPhone = document.getElementById('customerPhone');
    const menuPanel = document.getElementById('menuPanel');
    const menuContent = document.getElementById('menuContent');
    const menuNavBtns = document.querySelectorAll('.menu-nav-btn');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const micIndicator = document.getElementById('micIndicator');
    const menuBtn = document.getElementById('menuBtn'); // Define menuBtn

    // ===== ENHANCED TAXI MARKER (Completed Function) =====
    const BLACK_CAB_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 36" width="58" height="36">
  <rect x="4" y="14" width="50" height="14" rx="3" ry="3" fill="#000"/>
  <path d="M18 14v-4c0-3 2-5 5-5h12c3 0 5 2 5 5v4h-22z" fill="#000"/>
  <rect x="25" y="4" width="8" height="3" rx="1" fill="#FFD700" stroke="#000" stroke-width="0.5"/>
  <text x="29" y="6.6" text-anchor="middle" font-size="2.2" font-weight="bold" fill="#000" font-family="Arial, sans-serif">TAXI</text>
  <rect x="21" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <rect x="31" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <circle cx="15" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
  <circle cx="43" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
</svg>
`;
    function createBlackCabIcon(heading = 0) {
      const div = document.createElement('div');
      div.innerHTML = BLACK_CAB_SVG;
      const svg = div.firstElementChild;
      svg.style.transform = `rotate(${heading}deg)`;
      svg.style.transformOrigin = 'center';
      return L.divIcon({
        html: svg.outerHTML,
        iconSize: [58, 36],
        iconAnchor: [29, 18],
        className: 'taxi-marker'
      });
    }
    // ... (utility functions already in the original file) ...
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const œÜ1 = (lat1 * Math.PI) / 180;
      const œÜ2 = (lat2 * Math.PI) / 180;
      const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
      const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function updateDriverMarker(lat, lng, headingValue) {
      if (!driverMarker) return;
      driverMarker.setLatLng([lat, lng]);
      driverMarker.setIcon(createBlackCabIcon(headingValue));
    }

    function updateMapCenter(lat, lng) {
      if (!map) return;
      const center = map.getCenter();
      const dist = calculateDistance(center.lat, center.lng, lat, lng);
      // Only pan if the driver has moved 50 meters from the center of the current view
      if (dist > 50) map.panTo([lat, lng]);
    }

    let lastPublish = 0;
    let lastPublishCoords = null;
    function publishLocationThrottled(gpsData) {
      if (!client?.connected || driverPresence === 'offline') return;
      const now = Date.now();
      // Throttle: publish if moved >5m or if 3 seconds have passed
      if (!lastPublishCoords || calculateDistance(lastPublishCoords.lat, lastPublishCoords.lng, gpsData.lat, gpsData.lng) > 5 || now - lastPublish > 3000) {
        client.publish(LOCATION_TOPIC, JSON.stringify({
          driver: DRIVER_ID,
          lat: gpsData.lat,
          lng: gpsData.lng,
          status: driverPresence,
          ts: now,
          heading: Math.round(gpsData.heading)
        }));
        lastPublish = now;
        lastPublishCoords = { lat: gpsData.lat, lng: gpsData.lng };
      }
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.warn('Wake Lock failed:', err);
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    }

    // Function to handle other drivers' location updates
    function handleOtherDriverLocation(data) {
      if (data.driver === DRIVER_ID) return;
      const driverId = data.driver;
      const color = getColorForDriver(driverId);
      const iconHtml = `<div class="other-driver-icon" style="background:${color}; transform:rotate(${data.heading || 0}deg)">${data.driver.substring(0, 2).toUpperCase()}</div>`;
      const icon = L.divIcon({ html: iconHtml, iconSize: [32, 32], iconAnchor: [16, 16] });

      if (otherDrivers[driverId]) {
        otherDrivers[driverId].setLatLng([data.lat, data.lng]).setIcon(icon);
      } else {
        otherDrivers[driverId] = L.marker([data.lat, data.lng], { icon: icon }).addTo(map)
          .bindPopup(`${data.driver} (${data.status})`);
      }
      driverStatus[driverId] = data.ts; // Track last seen
      if (isMenuOpen && currentView === 'chat') updateChatList();
    }

    // GPS & Map Initialization (Completed initGPS, initMapImmediately is OK)

    function initMapImmediately() {
      if (map) return;
      loadingOverlay.style.display = 'flex';
      map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        maxZoom: 18,
        minZoom: 10
      }).setView([51.5072, 0.1276], 13); // Default to London

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map);

      // Start GPS tracking which calls connectMQTT()
      initGPS();
      // Ensure the overlay disappears once location is found
      setTimeout(() => {
        if (loadingOverlay.style.display !== 'none') {
          loadingOverlay.style.display = 'none';
        }
      }, 5000);
    }

    function initGPS() {
      if (gpsWatchId || driverPresence === 'offline') return;
      requestWakeLock();

      gpsWatchId = navigator.geolocation.watchPosition(gpsSuccess, gpsError, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 8000
      });

      function gpsSuccess(position) {
        const gpsData = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          speed: position.coords.speed,
          heading: position.coords.heading
        };
        driverCoords = gpsData;
        loadingOverlay.style.display = 'none';

        if (!driverMarker) {
          driverMarker = L.marker([gpsData.lat, gpsData.lng], {
            icon: createBlackCabIcon(gpsData.heading)
          }).addTo(map);
          map.setView([gpsData.lat, gpsData.lng], 16);
        }

        updateDriverMarker(gpsData.lat, gpsData.lng, gpsData.heading);
        updateMapCenter(gpsData.lat, gpsData.lng);
        publishLocationThrottled(gpsData);

        // Update status bar
        let statusClass = 'gps-gps';
        if (gpsData.accuracy > 50) statusClass = 'gps-poor';
        else if (gpsData.accuracy > 20) statusClass = 'gps-network';

        statusEl.innerHTML = `
          <span class="gps-source ${statusClass}"></span>
          GPS: ${gpsData.lat.toFixed(5)}, ${gpsData.lng.toFixed(5)} | Acc: &plusmn;${Math.round(gpsData.accuracy)}m | Speed: ${gpsData.speed ? Math.round(gpsData.speed * 3.6) : '--'} km/h
        `;

        // Only connect to MQTT after first successful GPS lock
        if (!client) connectMQTT();
      }

      function gpsError(err) {
        statusEl.textContent = "GPS error: " + err.message;
        console.error("GPS error:", err);
        setTimeout(() => {
          if (driverPresence !== 'offline') {
            initGPS();
          }
        }, 5000);
      }
    }


    // ===== ROBUST VOICE INTERACTION (STT + TTS) - Completed Logic =====
    let speechRecognition = null;
    let isSpeaking = false;
    let voiceAttemptCount = 0;
    const MAX_VOICE_ATTEMPTS = 3;
    const LISTEN_TIMEOUT_MS = 8000;
    const TTS_TO_MIC_DELAY_MS = 600;

    function showMicIndicator() {
      micIndicator.style.display = 'block';
    }

    function hideMicIndicator() {
      micIndicator.style.display = 'none';
    }

    function speakFeedback(message, onDone = null) {
      if (!('speechSynthesis' in window)) {
        if (onDone) setTimeout(onDone, 100);
        return;
      }
      isSpeaking = true;
      stopVoiceListener();
      const utterance = new SpeechSynthesisUtterance(message);
      utterance.lang = 'en-GB';
      utterance.rate = 0.9;
      utterance.onend = () => {
        isSpeaking = false;
        if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
      };
      utterance.onerror = () => {
        isSpeaking = false;
        if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
      };
      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    }

    function startVoiceListener() {
      if (isSpeaking || speechRecognition) return;
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        console.warn("SpeechRecognition not supported");
        return;
      }
      speechRecognition = new SpeechRecognition();
      speechRecognition.lang = 'en-GB';
      speechRecognition.continuous = false;
      speechRecognition.interimResults = false;
      let timeoutId = null;

      speechRecognition.onstart = () => {
        showMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          if (speechRecognition) speechRecognition.stop();
        }, LISTEN_TIMEOUT_MS);
      };

      speechRecognition.onresult = (event) => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        const transcript = event.results[0][0].transcript.toLowerCase().trim();
        if (transcript.includes('accept')) {
          respondToJob(true);
        } else if (transcript.includes('reject')) {
          respondToJob(false);
        } else {
          speakFeedback("Command not recognized. Please say 'accept' or 'reject'.", () => {
            voiceAttemptCount++;
            promptForVoiceResponse();
          });
        }
        speechRecognition = null;
      };

      speechRecognition.onerror = (event) => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        console.error('Speech recognition error:', event.error);
        if (event.error !== 'no-speech') {
          voiceAttemptCount++;
        }
        speechRecognition = null;
        promptForVoiceResponse();
      };

      speechRecognition.onend = () => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        if (speechRecognition) speechRecognition = null;
      };

      try {
        speechRecognition.start();
      } catch(e) {
        if (e.name !== 'InvalidStateError') console.error(e);
      }
    }

    function stopVoiceListener() {
      hideMicIndicator();
      if (speechRecognition) {
        speechRecognition.abort();
        speechRecognition = null;
      }
    }

    function promptForVoiceResponse() {
      if (isSpeaking || !isJobActive) return;

      if (voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
        if (voiceAttemptCount === 0) {
          setTimeout(startVoiceListener, TTS_TO_MIC_DELAY_MS);
        } else {
          speakFeedback("Did not hear you. Please say ‚Äòaccept‚Äô or ‚Äòreject‚Äô.", () => {
            startVoiceListener();
          });
        }
      } else {
        speakFeedback("Sorry, I can't understand you. Please use the buttons.", () => {
          voiceAttemptCount = 0;
        });
      }
    }

    // ===== JOB HANDLING & LOGIC - Completed Logic =====
    function cleanupJob() {
      if (jobTimerInterval) {
        clearInterval(jobTimerInterval);
        jobTimerInterval = null;
      }
      jobPanel.style.display = 'none';
      stopVoiceListener();
      speechSynthesis.cancel();
      currentJob = null;
      isJobActive = false;
      if (pickupMarker) {
        map.removeLayer(pickupMarker);
        pickupMarker = null;
      }
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }
      if (jobWakeLock) {
        jobWakeLock.release();
        jobWakeLock = null;
      }
      voiceAttemptCount = 0;
    }

    async function requestJobWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          jobWakeLock = await navigator.wakeLock.request('screen');
          jobWakeLock.addEventListener('release', () => {
            jobWakeLock = null;
          });
        }
      } catch (err) {
        console.warn('Job Wake Lock failed:', err);
      }
    }

    function showJobPanel(job) {
      cleanupJob();

      currentJob = job;
      isJobActive = true;
      jobPanel.style.display = 'block';
      pickupLocation.textContent = `${job.pubName} (${job.lat.toFixed(5)}, ${job.lng.toFixed(5)})`;
      customerName.textContent = job.customerName || 'Not provided';
      customerPhone.textContent = job.customerPhone || 'Not provided';

      if (map) {
        const pickupCoords = [job.lat, job.lng];
        pickupMarker = L.marker(pickupCoords, { icon: L.icon({ iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png', iconSize: [25, 41], iconAnchor: [12, 41] }) }).addTo(map).bindPopup("New Pickup").openPopup();
        map.panTo(pickupCoords);
        if (driverCoords) {
          routeLine = L.polyline([[driverCoords.lat, driverCoords.lng], pickupCoords], { color: 'red', weight: 4, dashArray: '10, 10' }).addTo(map);
        }
      }

      speakFeedback(`New job! Pickup at ${job.pubName}. Say accept or reject now.`, () => {
        const timerEl = document.getElementById('jobTimer');
        const secondsEl = document.getElementById('timerSeconds');
        let timeLeft = 30;

        secondsEl.textContent = timeLeft;
        timerEl.style.display = 'block';

        jobTimerInterval = setInterval(() => {
          timeLeft--;
          secondsEl.textContent = timeLeft;
          if (timeLeft <= 0) {
            clearInterval(jobTimerInterval);
            respondToJob(false, currentJob, 'expired');
          }
        }, 1000);

        requestJobWakeLock();
        promptForVoiceResponse();
      });
    }

    function processNextJob() {
      if (isJobActive || pendingJobs.length === 0 || driverPresence !== 'available') return;
      const job = pendingJobs.shift();
      savePendingJobs();
      showJobPanel(job);
    }

    function respondToJob(accepted, job = currentJob, statusOverride = null) {
      if (!job || !client) { cleanupJob(); return; }

      cleanupJob();

      const status = statusOverride || (accepted ? "bidding" : "rejected");

      const payload = {
        job: job.job,
        driver: DRIVER_ID,
        status: status,
        lat: driverCoords?.lat || job.lat,
        lng: driverCoords?.lng || job.lng,
        ts: Date.now()
      };

      client.publish(`jobs/${job.job}/status`, JSON.stringify(payload));

      if (accepted) {
        statusEl.innerHTML = '‚úÖ Bid sent. Waiting for result...';
        updateJobStatus(job.job, 'bidding');
      } else if (status === 'rejected') {
        statusEl.innerHTML = '‚ùå Job rejected';
        updateJobStatus(job.job, 'rejected');
      } else if (status === 'expired') {
        statusEl.innerHTML = '‚è±Ô∏è Job expired';
        updateJobStatus(job.job, 'expired');
      }

      setTimeout(() => processNextJob(), 2000);
    }

    function saveJobs() {
      localStorage.setItem(`driver_jobs_${DRIVER_ID}`, JSON.stringify(driverJobs));
    }

    function addJobToHistory(jobData, initialStatus = 'queued') {
      const job = { ...jobData, status: initialStatus, timestamp: Date.now(), driver: DRIVER_ID };
      const existingIndex = driverJobs.findIndex(j => j.job === job.job);
      if (existingIndex >= 0) {
        driverJobs[existingIndex] = job;
      } else {
        driverJobs.unshift(job);
        if (driverJobs.length > 50) {
          driverJobs = driverJobs.slice(0, 50);
        }
      }
      saveJobs();
      if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
      if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
    }

    function updateJobStatus(jobId, status) {
      const jobIndex = driverJobs.findIndex(j => j.job === jobId);
      if (jobIndex >= 0) {
        driverJobs[jobIndex].status = status;
        saveJobs();
        if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
        if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
      }
    }

    // ===== MENU RENDERING LOGIC - Completed Logic (omitted for brevity, but contained in the thought block) =====
    function renderCurrentJob() {
      const allocatedJobs = driverJobs.filter(job => job.status === 'allocated');
      if (allocatedJobs.length === 0) {
        menuContent.innerHTML = `
          <div class="no-current-job">
            <div class="icon">üöï</div>
            <div>You are currently **available**.</div>
            <div style="margin-top:10px;">No allocated jobs.</div>
          </div>
        `;
        return;
      }

      const current = allocatedJobs[0];

      menuContent.innerHTML = `
        <div class="current-job-info">
          <h3 style="margin-top:0; color:#28a745;">‚úÖ Allocated Job Details</h3>
          <div class="job-detail">
            <div class="job-label">Job ID</div>
            <div class="job-value">${current.job}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Pickup Location</div>
            <div class="job-value">${current.pubName}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Customer Name</div>
            <div class="job-value">${current.customerName || 'N/A'}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Customer Phone</div>
            <div class="job-value">${current.customerPhone || 'N/A'}</div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button class="settings-btn" id="navToPickupBtn">üß≠ Navigate to Pickup</button>
          <button class="settings-btn" id="callCustomerBtn" style="background:#28a745;">üìû Call Customer</button>
          <button class="settings-btn" onclick="markJobCompleted('${current.job}')">Mark as Completed</button>
        </div>
      `;

      document.getElementById('navToPickupBtn').addEventListener('click', () => {
        const url = `https://www.google.com/maps/dir/?api=1&destination=${current.lat},${current.lng}`;
        window.open(url, '_blank');
      });

      document.getElementById('callCustomerBtn').addEventListener('click', () => {
        const phone = current.customerPhone.replace(/\D/g, '');
        if (phone) {
          window.location.href = `tel:${phone}`;
        } else {
          alert("Customer phone number not available.");
        }
      });
    }

    function renderJobHistory() {
      menuContent.innerHTML = '';
      if (driverJobs.length === 0) {
        menuContent.innerHTML = '<div style="text-align:center; padding:50px 20px; color:#666;">No jobs in history</div>';
        return;
      }

      const jobsContainer = document.createElement('div');
      jobsContainer.id = 'jobHistoryContent';

      driverJobs.forEach(job => {
        const jobEl = document.createElement('div');
        jobEl.className = `job-item ${job.status}`;
        jobEl.dataset.jobId = job.job;

        let startX = 0;
        let currentX = 0;
        let isSwiping = false;

        const handleStart = (clientX) => {
          startX = clientX;
          isSwiping = true;
          jobEl.style.transition = '';
          jobEl.classList.add('swiping');
        };

        const handleMove = (clientX) => {
          if (!isSwiping) return;
          currentX = clientX;
          const diff = currentX - startX;
          if (diff > 0) {
            jobEl.style.transform = `translateX(${diff}px)`;
          }
        };

        const handleEnd = () => {
          if (!isSwiping) return;
          jobEl.classList.remove('swiping');
          const diff = currentX - startX;
          jobEl.style.transition = 'transform 0.3s ease';
          jobEl.style.transform = '';
          isSwiping = false;

          if (diff > 50) {
            const jobId = jobEl.dataset.jobId;
            if (confirm("üóëÔ∏è Delete this job permanently?")) {
              jobEl.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
              jobEl.style.transform = 'translateX(100vw)';
              jobEl.style.opacity = '0';
              setTimeout(() => {
                driverJobs = driverJobs.filter(j => j.job !== jobId);
                saveJobs();
                if (isMenuOpen && currentView === 'jobHistory') {
                  renderJobHistory();
                }
              }, 300);
            }
          }
        };

        jobEl.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
        jobEl.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
        jobEl.addEventListener('touchend', handleEnd);
        jobEl.addEventListener('mousedown', e => handleStart(e.clientX));
        jobEl.addEventListener('mousemove', e => handleMove(e.clientX));
        jobEl.addEventListener('mouseup', handleEnd);
        jobEl.addEventListener('mouseleave', () => {
          if (isSwiping) {
            jobEl.classList.remove('swiping');
            jobEl.style.transform = '';
            isSwiping = false;
          }
        });
        jobEl.addEventListener('selectstart', e => e.preventDefault());

        const date = new Date(job.timestamp);
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateStr = date.toLocaleDateString();

        let actionButtons = '';
        if (job.status === 'queued') {
          actionButtons = `
            <div style="display:flex; gap:8px; margin-top:12px;">
              <button class="settings-btn" style="flex:1; padding:8px; font-size:14px;" data-action="view" data-jobid="${job.job}"> View Details </button>
              <button class="settings-btn" style="flex:1; padding:8px; font-size:14px; background:#28a745;" data-action="bid" data-jobid="${job.job}"> üí∞ Bid Now </button>
            </div>
          `;
        }

        jobEl.innerHTML = `
          <div class="job-id">${job.job}</div>
          <div class="job-pub">Pub: ${job.pubName}</div>
          <div class="job-phone">üë§ ${job.customerName || '‚Äî'}</div>
          <div class="job-phone">üìû ${job.customerPhone}</div>
          <div class="job-phone">üìç ${job.lat.toFixed(5)}, ${job.lng.toFixed(5)}</div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
            <span class="job-status status-${job.status}">${job.status.toUpperCase()}</span>
            <span style="font-size:12px; color:#999;">${dateStr} ${timeStr}</span>
          </div>
          ${actionButtons}
        `;
        jobsContainer.appendChild(jobEl);
      });

      menuContent.appendChild(jobsContainer);

      jobsContainer.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = btn.dataset.action;
          const jobId = btn.dataset.jobid;
          const job = driverJobs.find(j => j.job === jobId);
          if (!job) return;

          if (action === 'bid') {
            const pending = pendingJobs.find(p => p.job === jobId);
            if (pending) {
              pendingJobs.unshift(pending);
              savePendingJobs();
              processNextJob();
              toggleMenu();
            } else {
              respondToJob(true, job);
              toggleMenu();
            }
          } else if (action === 'view') {
            alert(`Job Details:
              ID: ${job.job}
              Pickup: ${job.pubName}
              Customer: ${job.customerName || 'N/A'}
              Status: ${job.status.toUpperCase()}`);
          }
        });
      });
    }

    function renderChatMessages(chatId) {
      currentChat = chatId;
      unreadCounts[chatId] = 0;
      saveChatMessages();
      updateChatList();

      const chatMessagesEl = document.getElementById('chatMessages');
      const chatInputContainer = document.getElementById('chatInputContainer');
      const chatList = document.getElementById('chatList');

      chatList.style.display = 'none';
      chatMessagesEl.style.display = 'flex';
      chatInputContainer.style.display = 'flex';

      const messages = chatMessages[chatId] || [];

      chatMessagesEl.innerHTML = '';
      messages.forEach(msg => {
        const sender = msg.sender;
        const text = msg.text;
        const date = new Date(msg.timestamp);
        const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) || '--:--';

        const messageEl = document.createElement('div');
        messageEl.className = `message ${sender === DRIVER_ID ? 'sent' : 'received'}`;
        messageEl.innerHTML = `
          ${text}
          <div class="message-info">
            <span>${sender}</span>
            <span>${time}</span>
          </div>
        `;
        chatMessagesEl.appendChild(messageEl);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;

      const appTitle = document.getElementById('appTitle');
      appTitle.onclick = () => {
        appTitle.onclick = toggleMenu;
        currentChat = null;
        renderChatView();
      };

      const sendBtn = document.getElementById('sendBtn');
      const chatInput = document.getElementById('chatInput');
      sendBtn.onclick = sendChatMessage;
      chatInput.onkeypress = (e) => {
        if (e.key === 'Enter') sendChatMessage();
      };
    }

    function renderChatView() {
      if (currentChat) {
        renderChatMessages(currentChat);
        return;
      }

      menuContent.innerHTML = `
        <div id="chatContent" style="height:100%; display:flex; flex-direction:column;">
          <div id="chatList" style="flex:1; overflow-y:auto; padding:8px;">
            </div>
          <div id="chatMessages" style="flex:1; padding:16px; overflow-y:auto; display:none; flex-direction:column; gap:12px;"></div>
          <div id="chatInputContainer" style="padding:12px; background:white; border-top:1px solid #eee; display:none;">
            <input type="text" id="chatInput" placeholder="Type a message..." autocomplete="off" style="flex:1; padding:14px; border:2px solid #ddd; border-radius:24px; font-size:16px;">
            <button id="sendBtn" style="background:#000; color:#FFD700; border:none; width:52px; height:52px; border-radius:50%; margin-left:12px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:20px; box-shadow:0 2px 8px rgba(0,0,0,0.2);">‚û§</button>
          </div>
        </div>
      `;

      updateChatList();

      document.getElementById('chatList').addEventListener('click', (e) => {
        const item = e.target.closest('.contact-item');
        if (item && item.dataset.chat) {
          currentChat = item.dataset.chat;
          renderChatMessages(currentChat);
        }
      });
    }

    function updateChatList() {
      const chatList = document.getElementById('chatList');
      if (!chatList) return;

      let html = `
        <div class="contact-item" data-chat="group">
          <div class="other-driver-icon" style="background:#6f42c1;">GC</div>
          <div>
            <div class="contact-name">Group Chat</div>
            <div class="contact-status">All drivers</div>
          </div>
          ${unreadCounts.group > 0 ? `<div class="unread-badge">${unreadCounts.group}</div>` : ''}
        </div>
      `;

      Object.keys(otherDrivers).forEach(driverId => {
        if (driverId === DRIVER_ID) return;
        const isOnline = (Date.now() - (driverStatus[driverId] || 0)) < 60000;
        const color = getColorForDriver(driverId);
        const unread = unreadCounts[driverId] || 0;

        html += `
          <div class="contact-item" data-chat="${driverId}">
            <div class="other-driver-icon" style="background:${color}">${driverId.substring(0, 2).toUpperCase()}</div>
            <div>
              <div class="contact-name">${driverId}</div>
              <div class="contact-status">${isOnline ? 'Online' : 'Offline'}</div>
            </div>
            ${unread > 0 ? `<div class="unread-badge">${unread}</div>` : ''}
          </div>
        `;
      });

      chatList.innerHTML = html;
    }

    function saveChatMessages() {
      localStorage.setItem(`chat_group_${DRIVER_ID}`, JSON.stringify(chatMessages.group));
    }

    function sendChatMessage() {
      const chatInput = document.getElementById('chatInput');
      if (!chatInput || !currentChat) return;
      const text = chatInput.value.trim();
      if (!text) return;

      const payload = { sender: DRIVER_ID, text, timestamp: Date.now() };

      if (currentChat === 'group') {
        client.publish(CHAT_GROUP_TOPIC, JSON.stringify(payload));
      } else {
        client.publish(`chat/private/${currentChat}/${DRIVER_ID}`, JSON.stringify(payload));
      }

      addMessage(currentChat, DRIVER_ID, text);
      chatInput.value = '';
    }

    function addMessage(chatId, sender, text, timestamp = Date.now()) {
      if (!chatMessages[chatId]) {
        chatMessages[chatId] = [];
        unreadCounts[chatId] = 0;
      }
      chatMessages[chatId].push({ sender, text, timestamp });

      if (chatMessages[chatId].length > 50) {
        chatMessages[chatId] = chatMessages[chatId].slice(-50);
      }

      if (isMenuOpen && currentView === 'chat' && currentChat === chatId) {
        renderChatMessages(chatId);
      } else if (sender !== DRIVER_ID) {
        unreadCounts[chatId] = (unreadCounts[chatId] || 0) + 1;
        if (isMenuOpen && currentView === 'chat') {
          updateChatList();
        }
      }

      saveChatMessages();
    }

    function renderSettingsView() {
      menuContent.innerHTML = `
        <div class="settings-group">
          <div class="settings-label">Driver ID</div>
          <div class="settings-info">Your current ID: <span id="currentDriverId" style="font-weight:700;">${DRIVER_ID}</span></div>
          <input type="text" id="newDriverIdInput" class="settings-input" placeholder="Enter new ID (e.g., TAXI007)">
          <button class="settings-btn" id="saveDriverIdBtn">Update Driver ID</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">Job Radius (GPS Filter)</div>
          <div class="settings-info">Jobs further than this distance will be ignored.</div>
          <input type="number" id="maxRadiusInput" class="settings-input" value="${maxRadius}" min="1" max="50" step="1" placeholder="Max distance in km">
          <button class="settings-btn" id="saveRadiusBtn">Save Radius</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">History Management</div>
          <div class="settings-info">Clearing history will not affect allocated jobs or pending jobs.</div>
          <button class="settings-btn" id="clearJobsBtn" style="background:#dc3545;">Clear Job History & Pending Queue</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">About</div>
          <div class="settings-info">
            Black Cab Unite Driver App v7.0 (PWA)<br>
            Developed for real-time dispatch using MQTT, Firebase FCM, and Leaflet.
          </div>
        </div>
      `;

      document.getElementById('saveDriverIdBtn').addEventListener('click', () => {
        const newId = document.getElementById('newDriverIdInput').value.trim();
        if (!newId) return;
        if (!/^[a-zA-Z0-9_-]+$/.test(newId)) {
          alert("Invalid ID. Use letters, numbers, hyphens, and underscores.");
          return;
        }
        localStorage.setItem('driver_id', newId);
        DRIVER_ID = newId;
        document.getElementById('currentDriverId').textContent = newId;
        if (client) {
          client.end();
          setTimeout(() => connectMQTT(), 1000);
        }
        statusEl.innerHTML = `<span class="gps-source gps-gps"></span>‚úÖ Driver ID updated to: ${newId}`;
      });

      document.getElementById('saveRadiusBtn').addEventListener('click', () => {
        const val = document.getElementById('maxRadiusInput').value;
        const radius = parseFloat(val);
        if (isNaN(radius) || radius < 1 || radius > 50) {
          alert("Please enter a radius between 1 and 50 km");
          return;
        }
        maxRadius = radius;
        localStorage.setItem('max_radius_km', radius.toString());
        statusEl.innerHTML = `‚úÖ Max radius set to ${radius} km`;
      });

      document.getElementById('clearJobsBtn').addEventListener('click', () => {
        if (confirm("Are you sure you want to clear all job history?")) {
          driverJobs = [];
          pendingJobs = [];
          saveJobs();
          savePendingJobs();
          if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
          if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
          statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚úÖ Job history cleared';
        }
      });
    }

    function renderCurrentView() {
      switch (currentView) {
        case 'currentJob':
          renderCurrentJob();
          break;
        case 'jobHistory':
          renderJobHistory();
          break;
        case 'chat':
          renderChatView();
          break;
        case 'settings':
          renderSettingsView();
          break;
      }
    }

    function toggleMenu() {
      isMenuOpen = !isMenuOpen;
      menuPanel.classList.toggle('active', isMenuOpen);
      menuBtn.textContent = isMenuOpen ? '‚úï' : '‚ò∞';
      if (isMenuOpen) {
        renderCurrentView();
      }
    }

    window.markJobCompleted = function(jobId) {
      const payload = { job: jobId, driver: DRIVER_ID, status: "completed", ts: Date.now() };
      client.publish(`jobs/${jobId}/status`, JSON.stringify(payload));
      updateJobStatus(jobId, 'completed');
      isJobActive = false;
      cleanupJob();
      statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job marked as completed';
      if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
    };

    function getColorForDriver(driverId) {
      let hash = 0;
      for (let i = 0; i < driverId.length; i++) {
        hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
      }
      const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
      return "#" + "00000".substring(0, 6 - c.length) + c;
    }

    function setDriverPresence(status) {
      if (!['available', 'busy', 'offline'].includes(status)) return;
      driverPresence = status;
      localStorage.setItem('driver_presence', status);

      const caption = document.getElementById('statusCaption');
      caption.className = `status-${status}`;
      caption.innerHTML = `
        <span class="status-dot"></span> ${status.charAt(0).toUpperCase() + status.slice(1)}
      `;

      if (status === 'offline') {
        if (gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
        if (wakeLock) releaseWakeLock();
      } else if (!gpsWatchId) {
        initGPS();
      }
      if (client && DRIVER_ID) {
        client.publish(`drivers/${DRIVER_ID}/status`, JSON.stringify({ driver: DRIVER_ID, status: status, ts: Date.now() }));
      }
      if (status === 'available') {
        setTimeout(processNextJob, 500);
      }
    }

    function handleLogOff() {
      if (confirm("Are you sure you want to log off? This will stop GPS tracking and disconnect from the server.")) {
        setDriverPresence('offline');
        if (client) client.end();
        localStorage.clear();
        alert("Logged off successfully. Restart the app to log back in.");
        window.location.reload();
      }
    }

    // ===== MQTT CONNECTION & MESSAGE HANDLER - Completed Logic =====
    function connectMQTT() {
      if (client?.connected) return;
      console.log("Connecting to MQTT...");
      statusEl.textContent = "Connecting to broker...";

      client = mqtt.connect(MQTT_BROKER, {
        clientId: `driver_${DRIVER_ID}_${Math.random().toString(16).substr(2, 8)}`,
        clean: true,
        keepalive: 30
      });

      client.on('connect', () => {
        console.log("MQTT Connected.");
        statusEl.textContent = "MQTT Connected. Ready for jobs.";
        publishFcmToken();
        setDriverPresence(driverPresence);

        client.subscribe([
          REQUEST_TOPIC,
          DRIVERS_LOCATION_TOPIC,
          CHAT_GROUP_TOPIC,
          `chat/private/${DRIVER_ID}/+`,
          JOB_RESULT_TOPIC,
          `drivers/${DRIVER_ID}/presets`
        ], (err) => {
          if (err) console.error("Subscription failed:", err);
          else console.log("Subscribed to topics.");
        });

        // Timer to check for expired pending jobs
        setInterval(() => {
          const now = Date.now();
          let changed = false;
          pendingJobs = pendingJobs.filter(job => {
            if (now - job.receivedAt >= 30000) {
              updateJobStatus(job.job, 'expired');
              changed = true;
              return false;
            }
            return true;
          });
          if (changed) savePendingJobs();
        }, 10000);
      });

      client.on('message', (topic, message) => {
        try {
          const data = JSON.parse(message.toString());

          if (topic === `drivers/${DRIVER_ID}/presets`) {
            handlePassengerPreset(data);
            return;
          }

          if (topic.startsWith("pubs/requests/")) {
            const jobId = data.job;
            const isDuplicate = pendingJobs.some(p => p.job === jobId) || driverJobs.some(j => j.job === jobId);
            if (isDuplicate) {
              console.log("‚è≠Ô∏è Skipping duplicate job:", jobId);
              return;
            }

            pendingJobs.push({ ...data, receivedAt: Date.now(), pubName: data.location, customerName: data.customer, customerPhone: data.phone });
            savePendingJobs();
            addJobToHistory(data, 'queued');

            if (driverPresence === 'available' && !isJobActive) {
              processNextJob();
            } else if (driverPresence === 'busy') {
              if ('speechSynthesis' in window) {
                const u = new SpeechSynthesisUtterance("New job queued. You are set to busy.");
                u.lang = 'en-GB';
                u.rate = 0.9;
                speechSynthesis.speak(u);
              }
              const btn = document.getElementById('menuBtn');
              btn.style.transform = 'scale(1.1)';
              btn.style.backgroundColor = '#ff6b35';
              setTimeout(() => {
                btn.style.transform = '';
                btn.style.backgroundColor = '#FFD700';
              }, 600);
            }
            return;
          }

          if (topic.startsWith("jobs/") && topic.endsWith(`/result/${DRIVER_ID}`)) {
            const jobId = topic.split('/')[1];

            if (data.result === "won") {
              statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job allocated! Pickup: ' + (currentJob?.pubName || 'unknown');
              updateJobStatus(jobId, 'allocated');
              const modal = document.getElementById('jobWonModal');
              modal.style.display = 'flex';
              if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance("You won the job!");
                utterance.lang = 'en-GB';
                speechSynthesis.speak(utterance);
              }
              document.getElementById('closeJobWonModal').onclick = () => { modal.style.display = 'none'; };
            } else if (data.result === "lost") {
              statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚ùå Bid lost.';
              updateJobStatus(jobId, 'lost');
            }
            return;
          }

          if (topic.includes("/location") && !topic.includes(DRIVER_ID)) {
            handleOtherDriverLocation(data);
            return;
          }

          if (topic === CHAT_GROUP_TOPIC) {
            if (data.sender !== DRIVER_ID) {
              addMessage('group', data.sender, data.text, data.timestamp);
            }
            return;
          }

          if (topic.startsWith(`chat/private/${DRIVER_ID}/`)) {
            const sender = topic.split('/')[2];
            if (sender !== DRIVER_ID) {
              addMessage(sender, data.sender, data.text, data.timestamp);
            }
            return;
          }

          if (topic.includes("/status") && !topic.includes(DRIVER_ID)) {
            driverStatus[data.driver] = data.ts;
            if (isMenuOpen && currentView === 'chat' && !currentChat) updateChatList();
            return;
          }


        } catch (e) {
          console.error("Error processing MQTT message:", e, "Message:", message.toString());
        }
      });

      client.on('error', (err) => {
        console.error("MQTT Error:", err);
        statusEl.textContent = "MQTT Error. Reconnecting...";
        client.end();
        setTimeout(connectMQTT, 5000);
      });

      client.on('close', () => {
        console.log("MQTT Disconnected.");
        if (driverPresence !== 'offline') {
          statusEl.textContent = "MQTT Disconnected. Reconnecting...";
          setTimeout(connectMQTT, 5000);
        }
      });
    }


    // ===== FINAL EVENT LISTENERS & INITIALIZATION HOOKS =====
    menuBtn.addEventListener('click', toggleMenu);

    menuNavBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        menuNavBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;
        renderCurrentView();
      });
    });

    document.getElementById('acceptBtn').addEventListener('click', () => respondToJob(true));
    document.getElementById('rejectBtn').addEventListener('click', () => respondToJob(false));

    // Status dropdown toggle
    const appTitleContainer = document.getElementById('appTitleContainer');
    const statusDropdown = document.getElementById('statusDropdown');
    appTitleContainer.addEventListener('click', (e) => {
      e.stopPropagation();
      statusDropdown.style.display = statusDropdown.style.display === 'flex' ? 'none' : 'flex';
    });
    document.querySelectorAll('.status-option').forEach(option => {
      option.addEventListener('click', () => {
        const newStatus = option.dataset.status;
        setDriverPresence(newStatus);
        statusDropdown.style.display = 'none';
      });
    });
    document.getElementById('logOffBtn').addEventListener('click', handleLogOff);
    document.addEventListener('click', () => {
      statusDropdown.style.display = 'none';
    });
    statusDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Initialize app
    initMapImmediately();
  });

  </script>
</body>
</html>

