<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Black Cab Unite v7.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#000000">
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging-compat.js"></script>
  <style>
    /* ... (your existing CSS - unchanged) ... */
    body { 
      margin:0; 
      font-family:system-ui, -apple-system, "Segoe UI", sans-serif; 
      background:#f7fafc; 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      overflow:hidden;
    }
    #map { 
      flex:1; 
      width:100%;
      height:100%;
      z-index:1;
    }
    /* Black Cab Unite Header Banner */
    #headerBanner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: #000;
      color: #FFD700;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    #appTitleContainer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #appTitle {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    #appTitle::before {
      content: "üöï";
      font-size: 20px;
    }
    #statusCaption {
      font-size: 12px;
      color: #FFD700;
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .status-available .status-dot { background: #28a745; }
    .status-busy .status-dot { background: #ffc107; }
    .status-offline .status-dot { background: #dc3545; }
    #menuBtn {
      background: #FFD700;
      color: #000;
      border: none;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
      z-index: 1002;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: transform 0.1s ease;
    }
    #menuBtn:active {
      transform: scale(0.95);
    }
    /* === PASSENGER PRESET POPUP === */
    #passengerPopup {
      display: none;
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 18px 20px;
      border-radius: 16px;
      font-size: 16px;
      max-width: 300px;
      text-align: center;
      z-index: 3000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .replyBtn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      flex: 1;
      margin: 0 4px;
    }
    .replyBtn:nth-child(2) {
      background: #1f6feb;
    }
    /* Status bar at bottom */
    #status { 
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 16px;
      border-radius: 24px;
      font-size: 14px;
      color: #333;
      z-index: 1000;
      text-align: center;
      max-width: 90%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 600;
    }
    .gps-source {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .gps-gps { background: #28a745; }
    .gps-network { background: #17a2b8; }
    .gps-poor { background: #ffc107; }
    /* Job panel */
    #jobPanel { 
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 20px;
      border-top: 2px solid #eee;
      z-index: 1000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
      display: none;
    }
    #jobPanel h2 { 
      margin: 0 0 16px 0; 
      font-size: 20px; 
      color: #1f6feb;
      text-align: center;
    }
    #jobInfo { 
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 24px;
      font-size: 15px;
      line-height: 1.5;
    }
    .job-info-label {
      font-weight: 600;
      color: #495057;
      margin-bottom: 4px;
    }
    .job-info-value {
      font-size: 16px;
      color: #212529;
    }
    #jobTimer {
      margin-top: 12px;
      font-size: 14px;
      color: #dc3545;
      font-weight: bold;
      display: none;
    }
    .job-actions {
      display: flex;
      gap: 16px;
    }
    .job-btn {
      flex: 1;
      padding: 18px 12px;
      font-size: 18px;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 700;
      min-height: 56px;
    }
    .accept-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
    }
    .reject-btn {
      background: linear-gradient(135deg, #dc3545, #e83e8c);
      color: white;
    }
    /* Glowing Mic Indicator */
    #micIndicator {
      text-align: center;
      margin: 16px 0;
      display: none;
    }
    .mic-icon {
      width: 48px;
      height: 48px;
      background: #1f6feb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 12px #1f6feb;
      animation: micGlow 1.5s infinite alternate;
    }
    @keyframes micGlow {
      from { box-shadow: 0 0 12px #1f6feb; }
      to { box-shadow: 0 0 24px #1f6feb, 0 0 32px #1f6feb; }
    }
    .mic-label {
      font-size: 13px;
      color: #555;
      margin-top: 8px;
    }
    /* Driver icons */
    .other-driver-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 10px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    /* Loading overlay */
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
      color: white;
      font-size: 18px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Main Menu Panel */
    #menuPanel {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70vh;
      background: white;
      display: none;
      flex-direction: column;
      z-index: 2000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    #menuPanel.active {
      display: flex;
      transform: translateY(0);
    }
    #menuNav {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #eee;
    }
    .menu-nav-btn {
      flex: 1;
      background: transparent;
      border: none;
      padding: 16px 0;
      font-weight: 600;
      font-size: 15px;
      color: #666;
      cursor: pointer;
    }
    .menu-nav-btn.active {
      color: #1f6feb;
      background: #e8f0fe;
      border-bottom: 3px solid #1f6feb;
    }
    #menuContent {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .current-job-info {
      padding: 20px;
      background: #e8f5e8;
      border-radius: 12px;
      margin-bottom: 20px;
      border-left: 4px solid #28a745;
    }
    .job-detail {
      margin-bottom: 12px;
    }
    .job-label {
      font-weight: 700;
      color: #1f6feb;
      font-size: 15px;
      margin-bottom: 4px;
    }
    .job-value {
      font-size: 17px;
      color: #333;
      word-break: break-word;
    }
    .no-current-job {
      text-align: center;
      padding: 50px 20px;
      color: #666;
    }
    .no-current-job .icon {
      font-size: 60px;
      margin-bottom: 20px;
      opacity: 0.7;
    }
    .job-item {
      padding: 16px;
      border: 1px solid #eee;
      border-radius: 12px;
      margin-bottom: 12px;
      background: #f9f9f9;
      position: relative;
      overflow: hidden;
    }
    .job-item.allocated { border-left: 4px solid #28a745; background: #e8f5e8; }
    .job-item.processing, .job-item.bidding { border-left: 4px solid #1f6feb; background: #e8f0fe; }
    .job-item.completed { border-left: 4px solid #6c757d; background: #f8f9fa; }
    .job-item.lost, .job-item.rejected, .job-item.expired { border-left: 4px solid #dc3545; background: #f8d7da; }
    .job-item.queued { border-left: 4px solid #ffc107; background: #fff8e1; }
    .job-id { font-weight: 700; color: #1f6feb; margin-bottom: 6px; font-size: 16px; }
    .job-pub { font-size: 14px; color: #666; margin-bottom: 6px; }
    .job-phone { font-size: 15px; color: #333; margin-bottom: 6px; }
    .job-status {
      font-size: 12px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 6px;
    }
    .status-processing, .status-bidding { background: #d1e7ff; color: #084298; }
    .status-allocated { background: #d1e7dd; color: #0f5132; }
    .status-completed { background: #e2e3e5; color: #41464b; }
    .status-lost, .status-rejected, .status-expired { background: #f8d7da; color: #842029; }
    .status-queued { background: #fff3cd; color: #856404; }
    /* Swipe-to-delete with trash icon */
    .job-item::after {
      content: "üóëÔ∏è";
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      background: #dc3545;
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .job-item.swiping::after {
      opacity: 1;
    }
    #chatMessages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .message {
      max-width: 85%;
      padding: 14px 16px;
      border-radius: 20px;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
    }
    .received { background: #e9ecef; align-self: flex-start; border-bottom-left-radius: 6px; }
    .sent { background: #000; color: white; align-self: flex-end; border-bottom-right-radius: 6px; }
    .message-info {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
    }
    #chatInputContainer {
      display: flex;
      padding: 12px;
      background: white;
      border-top: 1px solid #eee;
    }
    #chatInput {
      flex: 1;
      padding: 14px;
      border: 2px solid #ddd;
      border-radius: 24px;
      font-size: 16px;
      outline: none;
    }
    #chatInput:focus {
      border-color: #1f6feb;
      box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.2);
    }
    #sendBtn {
      background: #000;
      color: #FFD700;
      border: none;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      margin-left: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #chatList {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .contact-item {
      padding: 16px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s;
    }
    .contact-item:hover {
      background: #f8f9fa;
    }
    .contact-name {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 4px;
    }
    .contact-status {
      font-size: 13px;
      color: #6c757d;
    }
    .contact-badge {
      background: #28a745;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    .offline { background: #6c757d; }
    .unread-badge {
      background: #FFD700;
      color: #000;
      border-radius: 12px;
      padding: 4px 8px;
      font-size: 12px;
      margin-left: 8px;
      font-weight: 700;
    }
    .settings-group {
      margin-bottom: 24px;
    }
    .settings-label {
      font-weight: 700;
      margin-bottom: 12px;
      color: #333;
      font-size: 16px;
    }
    .settings-input {
      width: 100%;
      padding: 14px;
      border: 2px solid #ccc;
      border-radius: 12px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .settings-input:focus {
      border-color: #1f6feb;
      outline: none;
    }
    .settings-btn {
      background: #1f6feb;
      color: white;
      border: none;
      padding: 16px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      margin-top: 12px;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(31, 111, 235, 0.3);
    }
    .settings-btn:hover {
      background: #1958c4;
      box-shadow: 0 6px 16px rgba(31, 111, 235, 0.4);
    }
    .settings-info {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      font-size: 14px;
      color: #666;
      line-height: 1.5;
    }
    /* Enhanced Taxi Marker */
    .taxi-marker {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="headerBanner">
    <div id="appTitleContainer">
      <div id="appTitle">Black Cab Unite v7.0</div>
      <div id="statusCaption" class="status-available">
        <span class="status-dot"></span> Available
      </div>
    </div>
    <button id="menuBtn">‚ò∞</button>
  </div>
  <div id="statusDropdown" style="
    position: absolute;
    top: 52px;
    left: 16px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1003;
    display: none;
    flex-direction: column;
    min-width: 180px;
  ">
    <div class="status-option" data-status="available" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#28a745; width:12px; height:12px; border-radius:50%;"></span> Available
    </div>
    <div class="status-option" data-status="busy" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#ffc107; width:12px; height:12px; border-radius:50%;"></span> Busy
    </div>
    <div class="status-option" data-status="offline" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#dc3545; width:12px; height:12px; border-radius:50%;"></span> Offline
    </div>
    <div id="logOffBtn" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px; border-top:1px solid #eee; color:#dc3545; font-weight:bold;">
      <span>üö™</span> Log Off
    </div>
  </div>
  <div id="status">Initializing...</div>
  <div id="jobPanel">
    <h2>üöï New Job Request</h2>
    <div id="jobInfo">
      <div class="job-info-label">Pickup Location</div>
      <div class="job-info-value" id="pickupLocation">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Name</div>
      <div class="job-info-value" id="customerName">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Phone</div>
      <div class="job-info-value" id="customerPhone">Loading...</div>
      <div id="jobTimer">‚è≥ Expires in: <span id="timerSeconds">30</span>s</div>
    </div>
    <div id="micIndicator">
      <div class="mic-icon">üé§</div>
      <div class="mic-label">Say ‚Äúaccept‚Äù or ‚Äúreject‚Äù</div>
    </div>
    <div class="job-actions">
      <button class="job-btn accept-btn" id="acceptBtn">‚úÖ ACCEPT JOB</button>
      <button class="job-btn reject-btn" id="rejectBtn">‚ùå REJECT</button>
    </div>
  </div>
  <div id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div>Loading map...</div>
  </div>
  <div id="menuPanel">
    <div id="menuNav">
      <button class="menu-nav-btn active" data-view="currentJob">üìç Current Job</button>
      <button class="menu-nav-btn" data-view="jobHistory">üìã Job History</button>
      <button class="menu-nav-btn" data-view="chat">üí¨ Chats</button>
      <button class="menu-nav-btn" data-view="settings">‚öôÔ∏è Settings</button>
    </div>
    <div id="menuContent"></div>
  </div>
  <div id="jobWonModal" style="
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  ">
    <div style="
      background: white;
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 320px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    ">
      <div style="font-size: 60px; margin-bottom: 16px;">üéâ</div>
      <h2 style="margin: 0 0 12px; color: #1f6feb;">You Won the Job!</h2>
      <p style="margin: 0 0 24px; color: #555;">Get ready to pick up the customer.</p>
      <button id="closeJobWonModal" style="
        background: #1f6feb;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 12px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
      ">Close</button>
    </div>
  </div>
  <div id="passengerPopup">
    <div id="passengerPopupMsg">Passenger message...</div>
    <div style="display:flex; justify-content:center; gap:10px; margin-top:12px;">
      <button id="presetReply1" class="replyBtn">On my way</button>
      <button id="presetReply2" class="replyBtn">Arrived</button>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script>
  // ===== FIREBASE INIT =====
  const firebaseConfig = {
    apiKey: "AIzaSyBq1aN-KRtRW7S243ef7lz7fnZmlBcuN1s",
    authDomain: "cabunite.firebaseapp.com",
    projectId: "cabunite",
    storageBucket: "cabunite.firebasestorage.app",
    messagingSenderId: "997924656033",
    appId: "1:997924656033:web:1552b9f26a1af0878eb1e0"
  };
  firebase.initializeApp(firebaseConfig);
  const messaging = firebase.messaging();

  messaging.onMessage((payload) => {
    console.log("üì≤ Foreground message received:", payload);
    if (Notification.permission === 'granted') {
      new Notification(payload.notification?.title || "Taxi Update", {
        body: payload.notification?.body || "You have a new message",
        icon: payload.notification?.icon || '/blackcabunite/icon-192.png'
      });
    }
  });

  // ‚úÖ GLOBAL fcmToken
  let fcmToken = null;

  document.addEventListener('DOMContentLoaded', () => {
    // ===== Driver Registration =====
    let DRIVER_ID = localStorage.getItem('driver_id');
    function validateDriverId(id) {
      if (!id) return false;
      return /^[a-zA-Z0-9_-]+$/.test(id);
    }
    if(!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
      while (!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
        DRIVER_ID = prompt("Enter your driver name or ID (letters, numbers, hyphens only):");
        if (DRIVER_ID === null) {
          DRIVER_ID = 'driver-' + Math.random().toString(36).substr(2, 8);
          break;
        }
      }
      localStorage.setItem('driver_id', DRIVER_ID);
    }

    // ===== FCM FUNCTIONS =====
    async function requestFCMToken() {
      try {
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
          console.warn('‚ö†Ô∏è Notification permission denied');
          return null;
        }

        const registration = await navigator.serviceWorker.register(
          '/blackcabunite/firebase-messaging-sw.js',
          { scope: '/blackcabunite/' }
        );

        // ‚úÖ Use GLOBAL fcmToken
        fcmToken = await messaging.getToken({
          vapidKey: "BJzV8Vx2sDvF6u9vGqK7vV5vD0U6X1aB5e4R3cN2mL1kJ0hI9gF8dC7bA6yZ5xW4vU3tS2rQ1pO0nM",
          serviceWorkerRegistration: registration
        });

        if (fcmToken) {
          console.log('‚úÖ FCM Token obtained');
          publishFcmToken(); // Safe: checks MQTT connection
        } else {
          console.warn('‚ö†Ô∏è No FCM token generated');
        }
        return fcmToken;
      } catch (err) {
        console.error('‚ùå FCM setup failed:', err);
        return null;
      }
    }

    function publishFcmToken() {
      if (!client?.connected) {
        console.log("‚è≥ MQTT not connected ‚Äî will retry on connect");
        return;
      }
      if (!fcmToken || !DRIVER_ID) {
        console.warn("‚ö†Ô∏è Missing FCM token or DRIVER_ID");
        return;
      }
      const payload = {
        driver: DRIVER_ID,
        fcmToken: fcmToken,
        ts: Date.now()
      };
      client.publish(`drivers/${DRIVER_ID}/fcm`, JSON.stringify(payload));
      console.log("üì§ Published FCM token via MQTT");
    }

    // ‚úÖ CALL FCM INIT AFTER DRIVER_ID IS SET
    if ('serviceWorker' in navigator && Notification.permission !== 'denied') {
      requestFCMToken();
    }

    // ===== Global State Variables and Constants =====
    let driverPresence = localStorage.getItem('driver_presence') || 'available';
    let ttsInitialized = false;
    function initTTS() {
      if (ttsInitialized || !('speechSynthesis' in window)) return;
      const utterance = new SpeechSynthesisUtterance('');
      utterance.volume = 0;
      speechSynthesis.speak(utterance);
      ttsInitialized = true;
    }
    document.body.addEventListener('click', initTTS, { once: true });
    document.body.addEventListener('touchstart', initTTS, { once: true });

    const MQTT_BROKER = "wss://broker.hivemq.com:8884/mqtt";
    const REQUEST_TOPIC = "pubs/requests/+";
    const LOCATION_TOPIC = `drivers/${DRIVER_ID}/location`;
    const DRIVERS_LOCATION_TOPIC = "drivers/+/location";
    const CHAT_GROUP_TOPIC = "chat/group";
    const JOB_RESULT_TOPIC = `jobs/+/result/${DRIVER_ID}`;

    // ===== PASSENGER PRESET HANDLING =====
    function handlePassengerPreset(data) {
      console.log("üí¨ Passenger preset received:", data);
      const preset = data?.presetType || "Unknown";
      const passengerMsg =
        preset === "where_are_you" ? "Passenger asks: Where are you?" :
        preset === "cancel_ride" ? "Passenger wants to cancel the ride." :
        preset === "call_driver" ? "Passenger is trying to call you." :
        `Passenger message: ${preset}`;

      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(passengerMsg);
        utterance.lang = 'en-GB';
        utterance.rate = 1;
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
      }
      showPassengerPopup(passengerMsg, data);
    }

    function showPassengerPopup(msg, data) {
      const popup = document.getElementById('passengerPopup');
      const msgEl = document.getElementById('passengerPopupMsg');
      msgEl.textContent = msg;
      popup.style.display = 'block';

      // Auto-hide popup after 15 seconds
      setTimeout(() => { popup.style.display = 'none'; }, 15000);

      document.getElementById('presetReply1').onclick = () => sendPresetReply('on_my_way', data);
      document.getElementById('presetReply2').onclick = () => sendPresetReply('arrived', data);
    }

    function sendPresetReply(type, data) {
      const payload = {
        type: 'driver_preset_reply',
        replyType: type,
        driverId: DRIVER_ID,
        jobId: data?.jobId || null,
        timestamp: new Date().toISOString()
      };
      client.publish('server/preset_replies', JSON.stringify(payload));
      document.getElementById('passengerPopup').style.display = 'none';
    }

    // ===== DEDUPLICATION & STATE MANAGEMENT HELPER =====
    function dedupeJobs(jobs) {
      const seen = new Set();
      return jobs.filter(job => {
        if (seen.has(job.job)) return false;
        seen.add(job.job);
        return true;
      });
    }
    function savePendingJobs() {
      localStorage.setItem(`pending_jobs_${DRIVER_ID}`, JSON.stringify(pendingJobs));
    }

    // Load and dedupe jobs
    let driverJobs = dedupeJobs(JSON.parse(localStorage.getItem(`driver_jobs_${DRIVER_ID}`)) || []);
    let pendingJobs = dedupeJobs(JSON.parse(localStorage.getItem(`pending_jobs_${DRIVER_ID}`)) || []);
    let driverCoords = null;
    let map = null;
    let driverMarker = null;
    let pickupMarker = null;
    let routeLine = null;
    let client = null;
    let isMenuOpen = false;
    let currentView = 'currentJob';
    let gpsWatchId = null;
    let wakeLock = null;
    const otherDrivers = {};
    const driverStatus = {};
    const chatMessages = { group: JSON.parse(localStorage.getItem(`chat_group_${DRIVER_ID}`)) || [] };
    const unreadCounts = { group: 0 };
    let maxRadius = parseFloat(localStorage.getItem('max_radius_km') || '10');
    let isJobActive = false;
    let currentChat = 'group';
    let jobTimerInterval = null;
    let jobWakeLock = null;

    const statusEl = document.getElementById('status');
    const jobPanel = document.getElementById('jobPanel');
    const pickupLocation = document.getElementById('pickupLocation');
    const customerName = document.getElementById('customerName');
    const customerPhone = document.getElementById('customerPhone');
    const menuPanel = document.getElementById('menuPanel');
    const menuContent = document.getElementById('menuContent');
    const menuNavBtns = document.querySelectorAll('.menu-nav-btn');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const micIndicator = document.getElementById('micIndicator');
    const menuBtn = document.getElementById('menuBtn'); // Define menuBtn

    // ===== ENHANCED TAXI MARKER (Completed Function) =====
    const BLACK_CAB_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 36" width="58" height="36">
  <rect x="4" y="14" width="50" height="14" rx="3" ry="3" fill="#000"/>
  <path d="M18 14v-4c0-3 2-5 5-5h12c3 0 5 2 5 5v4h-22z" fill="#000"/>
  <rect x="25" y="4" width="8" height="3" rx="1" fill="#FFD700" stroke="#000" stroke-width="0.5"/>
  <text x="29" y="6.6" text-anchor="middle" font-size="2.2" font-weight="bold" fill="#000" font-family="Arial, sans-serif">TAXI</text>
  <rect x="21" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <rect x="31" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <circle cx="15" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
  <circle cx="43" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
</svg>
`;
    function createBlackCabIcon(heading = 0) {
      const div = document.createElement('div');
      div.innerHTML = BLACK_CAB_SVG;
      const svg = div.firstElementChild;
      svg.style.transform = `rotate(${heading}deg)`;
      svg.style.transformOrigin = 'center';
      return L.divIcon({
        html: svg.outerHTML,
        iconSize: [58, 36],
        iconAnchor: [29, 18],
        className: 'taxi-marker'
      });
    }
    // ... (utility functions already in the original file) ...
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const œÜ1 = (lat1 * Math.PI) / 180;
      const œÜ2 = (lat2 * Math.PI) / 180;
      const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
      const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;
      const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function updateDriverMarker(lat, lng, headingValue) {
      if (!driverMarker) return;
      driverMarker.setLatLng([lat, lng]);
      driverMarker.setIcon(createBlackCabIcon(headingValue));
    }

    function updateMapCenter(lat, lng) {
      if (!map) return;
      const center = map.getCenter();
      const dist = calculateDistance(center.lat, center.lng, lat, lng);
      // Only pan if the driver has moved 50 meters from the center of the current view
      if (dist > 50) map.panTo([lat, lng]);
    }

    let lastPublish = 0;
    let lastPublishCoords = null;
    function publishLocationThrottled(gpsData) {
      if (!client?.connected || driverPresence === 'offline') return;
      const now = Date.now();
      // Throttle: publish if moved >5m or if 3 seconds have passed
      if (!lastPublishCoords || calculateDistance(lastPublishCoords.lat, lastPublishCoords.lng, gpsData.lat, gpsData.lng) > 5 || now - lastPublish > 3000) {
        client.publish(LOCATION_TOPIC, JSON.stringify({
          driver: DRIVER_ID,
          lat: gpsData.lat,
          lng: gpsData.lng,
          status: driverPresence,
          ts: now,
          heading: Math.round(gpsData.heading)
        }));
        lastPublish = now;
        lastPublishCoords = { lat: gpsData.lat, lng: gpsData.lng };
      }
    }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
        }
      } catch (err) {
        console.warn('Wake Lock failed:', err);
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    }

    // Function to handle other drivers' location updates
    function handleOtherDriverLocation(data) {
      if (data.driver === DRIVER_ID) return;
      const driverId = data.driver;
      const color = getColorForDriver(driverId);
      const iconHtml = `<div class="other-driver-icon" style="background:${color}; transform:rotate(${data.heading || 0}deg)">${data.driver.substring(0, 2).toUpperCase()}</div>`;
      const icon = L.divIcon({ html: iconHtml, iconSize: [32, 32], iconAnchor: [16, 16] });

      if (otherDrivers[driverId]) {
        otherDrivers[driverId].setLatLng([data.lat, data.lng]).setIcon(icon);
      } else {
        otherDrivers[driverId] = L.marker([data.lat, data.lng], { icon: icon }).addTo(map)
          .bindPopup(`${data.driver} (${data.status})`);
      }
      driverStatus[driverId] = data.ts; // Track last seen
      if (isMenuOpen && currentView === 'chat') updateChatList();
    }

    // GPS & Map Initialization (Completed initGPS, initMapImmediately is OK)

    function initMapImmediately() {
      if (map) return;
      loadingOverlay.style.display = 'flex';
      map = L.map('map', {
        zoomControl: false,
        attributionControl: false,
        maxZoom: 18,
        minZoom: 10
      }).setView([51.5072, 0.1276], 13); // Default to London

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      }).addTo(map);

      // Start GPS tracking which calls connectMQTT()
      initGPS();
      // Ensure the overlay disappears once location is found
      setTimeout(() => {
        if (loadingOverlay.style.display !== 'none') {
          loadingOverlay.style.display = 'none';
        }
      }, 5000);
    }

    function initGPS() {
      if (gpsWatchId || driverPresence === 'offline') return;
      requestWakeLock();

      gpsWatchId = navigator.geolocation.watchPosition(gpsSuccess, gpsError, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 8000
      });

      function gpsSuccess(position) {
        const gpsData = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          speed: position.coords.speed,
          heading: position.coords.heading
        };
        driverCoords = gpsData;
        loadingOverlay.style.display = 'none';

        if (!driverMarker) {
          driverMarker = L.marker([gpsData.lat, gpsData.lng], {
            icon: createBlackCabIcon(gpsData.heading)
          }).addTo(map);
          map.setView([gpsData.lat, gpsData.lng], 16);
        }

        updateDriverMarker(gpsData.lat, gpsData.lng, gpsData.heading);
        updateMapCenter(gpsData.lat, gpsData.lng);
        publishLocationThrottled(gpsData);

        // Update status bar
        let statusClass = 'gps-gps';
        if (gpsData.accuracy > 50) statusClass = 'gps-poor';
        else if (gpsData.accuracy > 20) statusClass = 'gps-network';

        statusEl.innerHTML = `
          <span class="gps-source ${statusClass}"></span>
          GPS: ${gpsData.lat.toFixed(5)}, ${gpsData.lng.toFixed(5)} | Acc: &plusmn;${Math.round(gpsData.accuracy)}m | Speed: ${gpsData.speed ? Math.round(gpsData.speed * 3.6) : '--'} km/h
        `;

        // Only connect to MQTT after first successful GPS lock
        if (!client) connectMQTT();
      }

      function gpsError(err) {
        statusEl.textContent = "GPS error: " + err.message;
        console.error("GPS error:", err);
        setTimeout(() => {
          if (driverPresence !== 'offline') {
            initGPS();
          }
        }, 5000);
      }
    }


    // ===== ROBUST VOICE INTERACTION (STT + TTS) - Completed Logic =====
    let speechRecognition = null;
    let isSpeaking = false;
    let voiceAttemptCount = 0;
    const MAX_VOICE_ATTEMPTS = 3;
    const LISTEN_TIMEOUT_MS = 8000;
    const TTS_TO_MIC_DELAY_MS = 600;

    function showMicIndicator() {
      micIndicator.style.display = 'block';
    }

    function hideMicIndicator() {
      micIndicator.style.display = 'none';
    }

    function speakFeedback(message, onDone = null) {
      if (!('speechSynthesis' in window)) {
        if (onDone) setTimeout(onDone, 100);
        return;
      }
      isSpeaking = true;
      stopVoiceListener();
      const utterance = new SpeechSynthesisUtterance(message);
      utterance.lang = 'en-GB';
      utterance.rate = 0.9;
      utterance.onend = () => {
        isSpeaking = false;
        if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
      };
      utterance.onerror = () => {
        isSpeaking = false;
        if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
      };
      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    }

    function startVoiceListener() {
      if (isSpeaking || speechRecognition) return;
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        console.warn("SpeechRecognition not supported");
        return;
      }
      speechRecognition = new SpeechRecognition();
      speechRecognition.lang = 'en-GB';
      speechRecognition.continuous = false;
      speechRecognition.interimResults = false;
      let timeoutId = null;

      speechRecognition.onstart = () => {
        showMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          if (speechRecognition) speechRecognition.stop();
        }, LISTEN_TIMEOUT_MS);
      };

      speechRecognition.onresult = (event) => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        const transcript = event.results[0][0].transcript.toLowerCase().trim();
        if (transcript.includes('accept')) {
          respondToJob(true);
        } else if (transcript.includes('reject')) {
          respondToJob(false);
        } else {
          speakFeedback("Command not recognized. Please say 'accept' or 'reject'.", () => {
            voiceAttemptCount++;
            promptForVoiceResponse();
          });
        }
        speechRecognition = null;
      };

      speechRecognition.onerror = (event) => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        console.error('Speech recognition error:', event.error);
        if (event.error !== 'no-speech') {
          voiceAttemptCount++;
        }
        speechRecognition = null;
        promptForVoiceResponse();
      };

      speechRecognition.onend = () => {
        hideMicIndicator();
        if (timeoutId) clearTimeout(timeoutId);
        if (speechRecognition) speechRecognition = null;
      };

      try {
        speechRecognition.start();
      } catch(e) {
        if (e.name !== 'InvalidStateError') console.error(e);
      }
    }

    function stopVoiceListener() {
      hideMicIndicator();
      if (speechRecognition) {
        speechRecognition.abort();
        speechRecognition = null;
      }
    }

    function promptForVoiceResponse() {
      if (isSpeaking || !isJobActive) return;

      if (voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
        if (voiceAttemptCount === 0) {
          setTimeout(startVoiceListener, TTS_TO_MIC_DELAY_MS);
        } else {
          speakFeedback("Did not hear you. Please say ‚Äòaccept‚Äô or ‚Äòreject‚Äô.", () => {
            startVoiceListener();
          });
        }
      } else {
        speakFeedback("Sorry, I can't understand you. Please use the buttons.", () => {
          voiceAttemptCount = 0;
        });
      }
    }

    // ===== JOB HANDLING & LOGIC - Completed Logic =====
    function cleanupJob() {
      if (jobTimerInterval) {
        clearInterval(jobTimerInterval);
        jobTimerInterval = null;
      }
      jobPanel.style.display = 'none';
      stopVoiceListener();
      speechSynthesis.cancel();
      currentJob = null;
      isJobActive = false;
      if (pickupMarker) {
        map.removeLayer(pickupMarker);
        pickupMarker = null;
      }
      if (routeLine) {
        map.removeLayer(routeLine);
        routeLine = null;
      }
      if (jobWakeLock) {
        jobWakeLock.release();
        jobWakeLock = null;
      }
      voiceAttemptCount = 0;
    }

    async function requestJobWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          jobWakeLock = await navigator.wakeLock.request('screen');
          jobWakeLock.addEventListener('release', () => {
            jobWakeLock = null;
          });
        }
      } catch (err) {
        console.warn('Job Wake Lock failed:', err);
      }
    }

    function showJobPanel(job) {
      cleanupJob();

      currentJob = job;
      isJobActive = true;
      jobPanel.style.display = 'block';
      pickupLocation.textContent = `${job.pubName} (${job.lat.toFixed(5)}, ${job.lng.toFixed(5)})`;
      customerName.textContent = job.customerName || 'Not provided';
      customerPhone.textContent = job.customerPhone || 'Not provided';

      if (map) {
        const pickupCoords = [job.lat, job.lng];
        pickupMarker = L.marker(pickupCoords, { icon: L.icon({ iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png', iconSize: [25, 41], iconAnchor: [12, 41] }) }).addTo(map).bindPopup("New Pickup").openPopup();
        map.panTo(pickupCoords);
        if (driverCoords) {
          routeLine = L.polyline([[driverCoords.lat, driverCoords.lng], pickupCoords], { color: 'red', weight: 4, dashArray: '10, 10' }).addTo(map);
        }
      }

      speakFeedback(`New job! Pickup at ${job.pubName}. Say accept or reject now.`, () => {
        const timerEl = document.getElementById('jobTimer');
        const secondsEl = document.getElementById('timerSeconds');
        let timeLeft = 30;

        secondsEl.textContent = timeLeft;
        timerEl.style.display = 'block';

        jobTimerInterval = setInterval(() => {
          timeLeft--;
          secondsEl.textContent = timeLeft;
          if (timeLeft <= 0) {
            clearInterval(jobTimerInterval);
            respondToJob(false, currentJob, 'expired');
          }
        }, 1000);

        requestJobWakeLock();
        promptForVoiceResponse();
      });
    }

    function processNextJob() {
      if (isJobActive || pendingJobs.length === 0 || driverPresence !== 'available') return;
      const job = pendingJobs.shift();
      savePendingJobs();
      showJobPanel(job);
    }

    function respondToJob(accepted, job = currentJob, statusOverride = null) {
      if (!job || !client) { cleanupJob(); return; }

      cleanupJob();

      const status = statusOverride || (accepted ? "bidding" : "rejected");

      const payload = {
        job: job.job,
        driver: DRIVER_ID,
        status: status,
        lat: driverCoords?.lat || job.lat,
        lng: driverCoords?.lng || job.lng,
        ts: Date.now()
      };

      client.publish(`jobs/${job.job}/status`, JSON.stringify(payload));

      if (accepted) {
        statusEl.innerHTML = '‚úÖ Bid sent. Waiting for result...';
        updateJobStatus(job.job, 'bidding');
      } else if (status === 'rejected') {
        statusEl.innerHTML = '‚ùå Job rejected';
        updateJobStatus(job.job, 'rejected');
      } else if (status === 'expired') {
        statusEl.innerHTML = '‚è±Ô∏è Job expired';
        updateJobStatus(job.job, 'expired');
      }

      setTimeout(() => processNextJob(), 2000);
    }

    function saveJobs() {
      localStorage.setItem(`driver_jobs_${DRIVER_ID}`, JSON.stringify(driverJobs));
    }

    function addJobToHistory(jobData, initialStatus = 'queued') {
      const job = { ...jobData, status: initialStatus, timestamp: Date.now(), driver: DRIVER_ID };
      const existingIndex = driverJobs.findIndex(j => j.job === job.job);
      if (existingIndex >= 0) {
        driverJobs[existingIndex] = job;
      } else {
        driverJobs.unshift(job);
        if (driverJobs.length > 50) {
          driverJobs = driverJobs.slice(0, 50);
        }
      }
      saveJobs();
      if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
      if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
    }

    function updateJobStatus(jobId, status) {
      const jobIndex = driverJobs.findIndex(j => j.job === jobId);
      if (jobIndex >= 0) {
        driverJobs[jobIndex].status = status;
        saveJobs();
        if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
        if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
      }
    }

    // ===== MENU RENDERING LOGIC - Completed Logic (omitted for brevity, but contained in the thought block) =====
    function renderCurrentJob() {
      const allocatedJobs = driverJobs.filter(job => job.status === 'allocated');
      if (allocatedJobs.length === 0) {
        menuContent.innerHTML = `
          <div class="no-current-job">
            <div class="icon">üöï</div>
            <div>You are currently **available**.</div>
            <div style="margin-top:10px;">No allocated jobs.</div>
          </div>
        `;
        return;
      }

      const current = allocatedJobs[0];

      menuContent.innerHTML = `
        <div class="current-job-info">
          <h3 style="margin-top:0; color:#28a745;">‚úÖ Allocated Job Details</h3>
          <div class="job-detail">
            <div class="job-label">Job ID</div>
            <div class="job-value">${current.job}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Pickup Location</div>
            <div class="job-value">${current.pubName}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Customer Name</div>
            <div class="job-value">${current.customerName || 'N/A'}</div>
          </div>
          <div class="job-detail">
            <div class="job-label">Customer Phone</div>
            <div class="job-value">${current.customerPhone || 'N/A'}</div>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button class="settings-btn" id="navToPickupBtn">üß≠ Navigate to Pickup</button>
          <button class="settings-btn" id="callCustomerBtn" style="background:#28a745;">üìû Call Customer</button>
          <button class="settings-btn" onclick="markJobCompleted('${current.job}')">Mark as Completed</button>
        </div>
      `;

      document.getElementById('navToPickupBtn').addEventListener('click', () => {
        const url = `https://www.google.com/maps/dir/?api=1&destination=${current.lat},${current.lng}`;
        window.open(url, '_blank');
      });

      document.getElementById('callCustomerBtn').addEventListener('click', () => {
        const phone = current.customerPhone.replace(/\D/g, '');
        if (phone) {
          window.location.href = `tel:${phone}`;
        } else {
          alert("Customer phone number not available.");
        }
      });
    }

    function renderJobHistory() {
      menuContent.innerHTML = '';
      if (driverJobs.length === 0) {
        menuContent.innerHTML = '<div style="text-align:center; padding:50px 20px; color:#666;">No jobs in history</div>';
        return;
      }

      const jobsContainer = document.createElement('div');
      jobsContainer.id = 'jobHistoryContent';

      driverJobs.forEach(job => {
        const jobEl = document.createElement('div');
        jobEl.className = `job-item ${job.status}`;
        jobEl.dataset.jobId = job.job;

        let startX = 0;
        let currentX = 0;
        let isSwiping = false;

        const handleStart = (clientX) => {
          startX = clientX;
          isSwiping = true;
          jobEl.style.transition = '';
          jobEl.classList.add('swiping');
        };

        const handleMove = (clientX) => {
          if (!isSwiping) return;
          currentX = clientX;
          const diff = currentX - startX;
          if (diff > 0) {
            jobEl.style.transform = `translateX(${diff}px)`;
          }
        };

        const handleEnd = () => {
          if (!isSwiping) return;
          jobEl.classList.remove('swiping');
          const diff = currentX - startX;
          jobEl.style.transition = 'transform 0.3s ease';
          jobEl.style.transform = '';
          isSwiping = false;

          if (diff > 50) {
            const jobId = jobEl.dataset.jobId;
            if (confirm("üóëÔ∏è Delete this job permanently?")) {
              jobEl.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
              jobEl.style.transform = 'translateX(100vw)';
              jobEl.style.opacity = '0';
              setTimeout(() => {
                driverJobs = driverJobs.filter(j => j.job !== jobId);
                saveJobs();
                if (isMenuOpen && currentView === 'jobHistory') {
                  renderJobHistory();
                }
              }, 300);
            }
          }
        };

        jobEl.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
        jobEl.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
        jobEl.addEventListener('touchend', handleEnd);
        jobEl.addEventListener('mousedown', e => handleStart(e.clientX));
        jobEl.addEventListener('mousemove', e => handleMove(e.clientX));
        jobEl.addEventListener('mouseup', handleEnd);
        jobEl.addEventListener('mouseleave', () => {
          if (isSwiping) {
            jobEl.classList.remove('swiping');
            jobEl.style.transform = '';
            isSwiping = false;
          }
        });
        jobEl.addEventListener('selectstart', e => e.preventDefault());

        const date = new Date(job.timestamp);
        const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateStr = date.toLocaleDateString();

        let actionButtons = '';
        if (job.status === 'queued') {
          actionButtons = `
            <div style="display:flex; gap:8px; margin-top:12px;">
              <button class="settings-btn" style="flex:1; padding:8px; font-size:14px;" data-action="view" data-jobid="${job.job}"> View Details </button>
              <button class="settings-btn" style="flex:1; padding:8px; font-size:14px; background:#28a745;" data-action="bid" data-jobid="${job.job}"> üí∞ Bid Now </button>
            </div>
          `;
        }

        jobEl.innerHTML = `
          <div class="job-id">${job.job}</div>
          <div class="job-pub">Pub: ${job.pubName}</div>
          <div class="job-phone">üë§ ${job.customerName || '‚Äî'}</div>
          <div class="job-phone">üìû ${job.customerPhone}</div>
          <div class="job-phone">üìç ${job.lat.toFixed(5)}, ${job.lng.toFixed(5)}</div>
          <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
            <span class="job-status status-${job.status}">${job.status.toUpperCase()}</span>
            <span style="font-size:12px; color:#999;">${dateStr} ${timeStr}</span>
          </div>
          ${actionButtons}
        `;
        jobsContainer.appendChild(jobEl);
      });

      menuContent.appendChild(jobsContainer);

      jobsContainer.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = btn.dataset.action;
          const jobId = btn.dataset.jobid;
          const job = driverJobs.find(j => j.job === jobId);
          if (!job) return;

          if (action === 'bid') {
            const pending = pendingJobs.find(p => p.job === jobId);
            if (pending) {
              pendingJobs.unshift(pending);
              savePendingJobs();
              processNextJob();
              toggleMenu();
            } else {
              respondToJob(true, job);
              toggleMenu();
            }
          } else if (action === 'view') {
            alert(`Job Details:
              ID: ${job.job}
              Pickup: ${job.pubName}
              Customer: ${job.customerName || 'N/A'}
              Status: ${job.status.toUpperCase()}`);
          }
        });
      });
    }

    function renderChatMessages(chatId) {
      currentChat = chatId;
      unreadCounts[chatId] = 0;
      saveChatMessages();
      updateChatList();

      const chatMessagesEl = document.getElementById('chatMessages');
      const chatInputContainer = document.getElementById('chatInputContainer');
      const chatList = document.getElementById('chatList');

      chatList.style.display = 'none';
      chatMessagesEl.style.display = 'flex';
      chatInputContainer.style.display = 'flex';

      const messages = chatMessages[chatId] || [];

      chatMessagesEl.innerHTML = '';
      messages.forEach(msg => {
        const sender = msg.sender;
        const text = msg.text;
        const date = new Date(msg.timestamp);
        const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) || '--:--';

        const messageEl = document.createElement('div');
        messageEl.className = `message ${sender === DRIVER_ID ? 'sent' : 'received'}`;
        messageEl.innerHTML = `
          ${text}
          <div class="message-info">
            <span>${sender}</span>
            <span>${time}</span>
          </div>
        `;
        chatMessagesEl.appendChild(messageEl);
      });
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;

      const appTitle = document.getElementById('appTitle');
      appTitle.onclick = () => {
        appTitle.onclick = toggleMenu;
        currentChat = null;
        renderChatView();
      };

      const sendBtn = document.getElementById('sendBtn');
      const chatInput = document.getElementById('chatInput');
      sendBtn.onclick = sendChatMessage;
      chatInput.onkeypress = (e) => {
        if (e.key === 'Enter') sendChatMessage();
      };
    }

    function renderChatView() {
      if (currentChat) {
        renderChatMessages(currentChat);
        return;
      }

      menuContent.innerHTML = `
        <div id="chatContent" style="height:100%; display:flex; flex-direction:column;">
          <div id="chatList" style="flex:1; overflow-y:auto; padding:8px;">
            </div>
          <div id="chatMessages" style="flex:1; padding:16px; overflow-y:auto; display:none; flex-direction:column; gap:12px;"></div>
          <div id="chatInputContainer" style="padding:12px; background:white; border-top:1px solid #eee; display:none;">
            <input type="text" id="chatInput" placeholder="Type a message..." autocomplete="off" style="flex:1; padding:14px; border:2px solid #ddd; border-radius:24px; font-size:16px;">
            <button id="sendBtn" style="background:#000; color:#FFD700; border:none; width:52px; height:52px; border-radius:50%; margin-left:12px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:20px; box-shadow:0 2px 8px rgba(0,0,0,0.2);">‚û§</button>
          </div>
        </div>
      `;

      updateChatList();

      document.getElementById('chatList').addEventListener('click', (e) => {
        const item = e.target.closest('.contact-item');
        if (item && item.dataset.chat) {
          currentChat = item.dataset.chat;
          renderChatMessages(currentChat);
        }
      });
    }

    function updateChatList() {
      const chatList = document.getElementById('chatList');
      if (!chatList) return;

      let html = `
        <div class="contact-item" data-chat="group">
          <div class="other-driver-icon" style="background:#6f42c1;">GC</div>
          <div>
            <div class="contact-name">Group Chat</div>
            <div class="contact-status">All drivers</div>
          </div>
          ${unreadCounts.group > 0 ? `<div class="unread-badge">${unreadCounts.group}</div>` : ''}
        </div>
      `;

      Object.keys(otherDrivers).forEach(driverId => {
        if (driverId === DRIVER_ID) return;
        const isOnline = (Date.now() - (driverStatus[driverId] || 0)) < 60000;
        const color = getColorForDriver(driverId);
        const unread = unreadCounts[driverId] || 0;

        html += `
          <div class="contact-item" data-chat="${driverId}">
            <div class="other-driver-icon" style="background:${color}">${driverId.substring(0, 2).toUpperCase()}</div>
            <div>
              <div class="contact-name">${driverId}</div>
              <div class="contact-status">${isOnline ? 'Online' : 'Offline'}</div>
            </div>
            ${unread > 0 ? `<div class="unread-badge">${unread}</div>` : ''}
          </div>
        `;
      });

      chatList.innerHTML = html;
    }

    function saveChatMessages() {
      localStorage.setItem(`chat_group_${DRIVER_ID}`, JSON.stringify(chatMessages.group));
    }

    function sendChatMessage() {
      const chatInput = document.getElementById('chatInput');
      if (!chatInput || !currentChat) return;
      const text = chatInput.value.trim();
      if (!text) return;

      const payload = { sender: DRIVER_ID, text, timestamp: Date.now() };

      if (currentChat === 'group') {
        client.publish(CHAT_GROUP_TOPIC, JSON.stringify(payload));
      } else {
        client.publish(`chat/private/${currentChat}/${DRIVER_ID}`, JSON.stringify(payload));
      }

      addMessage(currentChat, DRIVER_ID, text);
      chatInput.value = '';
    }

    function addMessage(chatId, sender, text, timestamp = Date.now()) {
      if (!chatMessages[chatId]) {
        chatMessages[chatId] = [];
        unreadCounts[chatId] = 0;
      }
      chatMessages[chatId].push({ sender, text, timestamp });

      if (chatMessages[chatId].length > 50) {
        chatMessages[chatId] = chatMessages[chatId].slice(-50);
      }

      if (isMenuOpen && currentView === 'chat' && currentChat === chatId) {
        renderChatMessages(chatId);
      } else if (sender !== DRIVER_ID) {
        unreadCounts[chatId] = (unreadCounts[chatId] || 0) + 1;
        if (isMenuOpen && currentView === 'chat') {
          updateChatList();
        }
      }

      saveChatMessages();
    }

    function renderSettingsView() {
      menuContent.innerHTML = `
        <div class="settings-group">
          <div class="settings-label">Driver ID</div>
          <div class="settings-info">Your current ID: <span id="currentDriverId" style="font-weight:700;">${DRIVER_ID}</span></div>
          <input type="text" id="newDriverIdInput" class="settings-input" placeholder="Enter new ID (e.g., TAXI007)">
          <button class="settings-btn" id="saveDriverIdBtn">Update Driver ID</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">Job Radius (GPS Filter)</div>
          <div class="settings-info">Jobs further than this distance will be ignored.</div>
          <input type="number" id="maxRadiusInput" class="settings-input" value="${maxRadius}" min="1" max="50" step="1" placeholder="Max distance in km">
          <button class="settings-btn" id="saveRadiusBtn">Save Radius</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">History Management</div>
          <div class="settings-info">Clearing history will not affect allocated jobs or pending jobs.</div>
          <button class="settings-btn" id="clearJobsBtn" style="background:#dc3545;">Clear Job History & Pending Queue</button>
        </div>

        <div class="settings-group">
          <div class="settings-label">About</div>
          <div class="settings-info">
            Black Cab Unite Driver App v7.0 (PWA)<br>
            Developed for real-time dispatch using MQTT, Firebase FCM, and Leaflet.
          </div>
        </div>
      `;

      document.getElementById('saveDriverIdBtn').addEventListener('click', () => {
        const newId = document.getElementById('newDriverIdInput').value.trim();
        if (!newId) return;
        if (!/^[a-zA-Z0-9_-]+$/.test(newId)) {
          alert("Invalid ID. Use letters, numbers, hyphens, and underscores.");
          return;
        }
        localStorage.setItem('driver_id', newId);
        DRIVER_ID = newId;
        document.getElementById('currentDriverId').textContent = newId;
        if (client) {
          client.end();
          setTimeout(() => connectMQTT(), 1000);
        }
        statusEl.innerHTML = `<span class="gps-source gps-gps"></span>‚úÖ Driver ID updated to: ${newId}`;
      });

      document.getElementById('saveRadiusBtn').addEventListener('click', () => {
        const val = document.getElementById('maxRadiusInput').value;
        const radius = parseFloat(val);
        if (isNaN(radius) || radius < 1 || radius > 50) {
          alert("Please enter a radius between 1 and 50 km");
          return;
        }
        maxRadius = radius;
        localStorage.setItem('max_radius_km', radius.toString());
        statusEl.innerHTML = `‚úÖ Max radius set to ${radius} km`;
      });

      document.getElementById('clearJobsBtn').addEventListener('click', () => {
        if (confirm("Are you sure you want to clear all job history?")) {
          driverJobs = [];
          pendingJobs = [];
          saveJobs();
          savePendingJobs();
          if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
          if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
          statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚úÖ Job history cleared';
        }
      });
    }

    function renderCurrentView() {
      switch (currentView) {
        case 'currentJob':
          renderCurrentJob();
          break;
        case 'jobHistory':
          renderJobHistory();
          break;
        case 'chat':
          renderChatView();
          break;
        case 'settings':
          renderSettingsView();
          break;
      }
    }

    function toggleMenu() {
      isMenuOpen = !isMenuOpen;
      menuPanel.classList.toggle('active', isMenuOpen);
      menuBtn.textContent = isMenuOpen ? '‚úï' : '‚ò∞';
      if (isMenuOpen) {
        renderCurrentView();
      }
    }

    window.markJobCompleted = function(jobId) {
      const payload = { job: jobId, driver: DRIVER_ID, status: "completed", ts: Date.now() };
      client.publish(`jobs/${jobId}/status`, JSON.stringify(payload));
      updateJobStatus(jobId, 'completed');
      isJobActive = false;
      cleanupJob();
      statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job marked as completed';
      if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
    };

    function getColorForDriver(driverId) {
      let hash = 0;
      for (let i = 0; i < driverId.length; i++) {
        hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
      }
      const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
      return "#" + "00000".substring(0, 6 - c.length) + c;
    }

    function setDriverPresence(status) {
      if (!['available', 'busy', 'offline'].includes(status)) return;
      driverPresence = status;
      localStorage.setItem('driver_presence', status);

      const caption = document.getElementById('statusCaption');
      caption.className = `status-${status}`;
      caption.innerHTML = `
        <span class="status-dot"></span> ${status.charAt(0).toUpperCase() + status.slice(1)}
      `;

      if (status === 'offline') {
        if (gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
        if (wakeLock) releaseWakeLock();
      } else if (!gpsWatchId) {
        initGPS();
      }
      if (client && DRIVER_ID) {
        client.publish(`drivers/${DRIVER_ID}/status`, JSON.stringify({ driver: DRIVER_ID, status: status, ts: Date.now() }));
      }
      if (status === 'available') {
        setTimeout(processNextJob, 500);
      }
    }

    function handleLogOff() {
      if (confirm("Are you sure you want to log off? This will stop GPS tracking and disconnect from the server.")) {
        setDriverPresence('offline');
        if (client) client.end();
        localStorage.clear();
        alert("Logged off successfully. Restart the app to log back in.");
        window.location.reload();
      }
    }

    // ===== MQTT CONNECTION & MESSAGE HANDLER - Completed Logic =====
    function connectMQTT() {
      if (client?.connected) return;
      console.log("Connecting to MQTT...");
      statusEl.textContent = "Connecting to broker...";

      client = mqtt.connect(MQTT_BROKER, {
        clientId: `driver_${DRIVER_ID}_${Math.random().toString(16).substr(2, 8)}`,
        clean: true,
        keepalive: 30
      });

      client.on('connect', () => {
        console.log("MQTT Connected.");
        statusEl.textContent = "MQTT Connected. Ready for jobs.";
        publishFcmToken();
        setDriverPresence(driverPresence);

        client.subscribe([
          REQUEST_TOPIC,
          DRIVERS_LOCATION_TOPIC,
          CHAT_GROUP_TOPIC,
          `chat/private/${DRIVER_ID}/+`,
          JOB_RESULT_TOPIC,
          `drivers/${DRIVER_ID}/presets`
        ], (err) => {
          if (err) console.error("Subscription failed:", err);
          else console.log("Subscribed to topics.");
        });

        // Timer to check for expired pending jobs
        setInterval(() => {
          const now = Date.now();
          let changed = false;
          pendingJobs = pendingJobs.filter(job => {
            if (now - job.receivedAt >= 30000) {
              updateJobStatus(job.job, 'expired');
              changed = true;
              return false;
            }
            return true;
          });
          if (changed) savePendingJobs();
        }, 10000);
      });

      client.on('message', (topic, message) => {
        try {
          const data = JSON.parse(message.toString());

          if (topic === `drivers/${DRIVER_ID}/presets`) {
            handlePassengerPreset(data);
            return;
          }

          if (topic.startsWith("pubs/requests/")) {
            const jobId = data.job;
            const isDuplicate = pendingJobs.some(p => p.job === jobId) || driverJobs.some(j => j.job === jobId);
            if (isDuplicate) {
              console.log("‚è≠Ô∏è Skipping duplicate job:", jobId);
              return;
            }

            pendingJobs.push({ ...data, receivedAt: Date.now(), pubName: data.location, customerName: data.customer, customerPhone: data.phone });
            savePendingJobs();
            addJobToHistory(data, 'queued');

            if (driverPresence === 'available' && !isJobActive) {
              processNextJob();
            } else if (driverPresence === 'busy') {
              if ('speechSynthesis' in window) {
                const u = new SpeechSynthesisUtterance("New job queued. You are set to busy.");
                u.lang = 'en-GB';
                u.rate = 0.9;
                speechSynthesis.speak(u);
              }
              const btn = document.getElementById('menuBtn');
              btn.style.transform = 'scale(1.1)';
              btn.style.backgroundColor = '#ff6b35';
              setTimeout(() => {
                btn.style.transform = '';
                btn.style.backgroundColor = '#FFD700';
              }, 600);
            }
            return;
          }

          if (topic.startsWith("jobs/") && topic.endsWith(`/result/${DRIVER_ID}`)) {
            const jobId = topic.split('/')[1];

            if (data.result === "won") {
              statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job allocated! Pickup: ' + (currentJob?.pubName || 'unknown');
              updateJobStatus(jobId, 'allocated');
              const modal = document.getElementById('jobWonModal');
              modal.style.display = 'flex';
              if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance("You won the job!");
                utterance.lang = 'en-GB';
                speechSynthesis.speak(utterance);
              }
              document.getElementById('closeJobWonModal').onclick = () => { modal.style.display = 'none'; };
            } else if (data.result === "lost") {
              statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚ùå Bid lost.';
              updateJobStatus(jobId, 'lost');
            }
            return;
          }

          if (topic.includes("/location") && !topic.includes(DRIVER_ID)) {
            handleOtherDriverLocation(data);
            return;
          }

          if (topic === CHAT_GROUP_TOPIC) {
            if (data.sender !== DRIVER_ID) {
              addMessage('group', data.sender, data.text, data.timestamp);
            }
            return;
          }

          if (topic.startsWith(`chat/private/${DRIVER_ID}/`)) {
            const sender = topic.split('/')[2];
            if (sender !== DRIVER_ID) {
              addMessage(sender, data.sender, data.text, data.timestamp);
            }
            return;
          }

          if (topic.includes("/status") && !topic.includes(DRIVER_ID)) {
            driverStatus[data.driver] = data.ts;
            if (isMenuOpen && currentView === 'chat' && !currentChat) updateChatList();
            return;
          }


        } catch (e) {
          console.error("Error processing MQTT message:", e, "Message:", message.toString());
        }
      });

      client.on('error', (err) => {
        console.error("MQTT Error:", err);
        statusEl.textContent = "MQTT Error. Reconnecting...";
        client.end();
        setTimeout(connectMQTT, 5000);
      });

      client.on('close', () => {
        console.log("MQTT Disconnected.");
        if (driverPresence !== 'offline') {
          statusEl.textContent = "MQTT Disconnected. Reconnecting...";
          setTimeout(connectMQTT, 5000);
        }
      });
    }


    // ===== FINAL EVENT LISTENERS & INITIALIZATION HOOKS =====
    menuBtn.addEventListener('click', toggleMenu);

    menuNavBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        menuNavBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;
        renderCurrentView();
      });
    });

    document.getElementById('acceptBtn').addEventListener('click', () => respondToJob(true));
    document.getElementById('rejectBtn').addEventListener('click', () => respondToJob(false));

    // Status dropdown toggle
    const appTitleContainer = document.getElementById('appTitleContainer');
    const statusDropdown = document.getElementById('statusDropdown');
    appTitleContainer.addEventListener('click', (e) => {
      e.stopPropagation();
      statusDropdown.style.display = statusDropdown.style.display === 'flex' ? 'none' : 'flex';
    });
    document.querySelectorAll('.status-option').forEach(option => {
      option.addEventListener('click', () => {
        const newStatus = option.dataset.status;
        setDriverPresence(newStatus);
        statusDropdown.style.display = 'none';
      });
    });
    document.getElementById('logOffBtn').addEventListener('click', handleLogOff);
    document.addEventListener('click', () => {
      statusDropdown.style.display = 'none';
    });
    statusDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Initialize app
    initMapImmediately();
  });

  </script>
</body>
</html>
