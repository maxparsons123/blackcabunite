<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Black Cab Unite v7.0</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <!-- PWA -->
  <link rel="manifest" href="./manifest.json">
  <meta name="theme-color" content="#000000">
  <!-- Firebase Compat SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-messaging-compat.js"></script>
  <style>
    body { 
      margin:0; 
      font-family:system-ui, -apple-system, "Segoe UI", sans-serif; 
      background:#f7fafc; 
      display:flex; 
      flex-direction:column; 
      height:100vh; 
      overflow:hidden;
    }
    #map { 
      flex:1; 
      width:100%;
      height:100%;
      z-index:1;
    }
    /* Black Cab Unite Header Banner */
    #headerBanner {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: #000;
      color: #FFD700;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    #appTitleContainer {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    #appTitle {
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }
    #appTitle::before {
      content: "üöï";
      font-size: 20px;
    }
    #statusCaption {
      font-size: 12px;
      color: #FFD700;
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .status-available .status-dot { background: #28a745; }
    .status-busy .status-dot { background: #ffc107; }
    .status-offline .status-dot { background: #dc3545; }
    #menuBtn {
      background: #FFD700;
      color: #000;
      border: none;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
      z-index: 1002;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: transform 0.1s ease;
    }
    #menuBtn:active {
      transform: scale(0.95);
    }
    /* === PASSENGER PRESET POPUP === */
    #passengerPopup {
      display: none;
      position: fixed;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 18px 20px;
      border-radius: 16px;
      font-size: 16px;
      max-width: 300px;
      text-align: center;
      z-index: 3000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .replyBtn {
      background: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      flex: 1;
      margin: 0 4px;
    }
    .replyBtn:nth-child(2) {
      background: #1f6feb;
    }
    /* Status bar at bottom */
    #status { 
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 16px;
      border-radius: 24px;
      font-size: 14px;
      color: #333;
      z-index: 1000;
      text-align: center;
      max-width: 90%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-weight: 600;
    }
    .gps-source {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 6px;
    }
    .gps-gps { background: #28a745; }
    .gps-network { background: #17a2b8; }
    .gps-poor { background: #ffc107; }
    /* Job panel */
    #jobPanel { 
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      padding: 20px;
      border-top: 2px solid #eee;
      z-index: 1000;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.1);
      display: none;
    }
    #jobPanel h2 { 
      margin: 0 0 16px 0; 
      font-size: 20px; 
      color: #1f6feb;
      text-align: center;
    }
    #jobInfo { 
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 24px;
      font-size: 15px;
      line-height: 1.5;
    }
    .job-info-label {
      font-weight: 600;
      color: #495057;
      margin-bottom: 4px;
    }
    .job-info-value {
      font-size: 16px;
      color: #212529;
    }
    #jobTimer {
      margin-top: 12px;
      font-size: 14px;
      color: #dc3545;
      font-weight: bold;
      display: none;
    }
    .job-actions {
      display: flex;
      gap: 16px;
    }
    .job-btn {
      flex: 1;
      padding: 18px 12px;
      font-size: 18px;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 700;
      min-height: 56px;
    }
    .accept-btn {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
    }
    .reject-btn {
      background: linear-gradient(135deg, #dc3545, #e83e8c);
      color: white;
    }
    /* Glowing Mic Indicator */
    #micIndicator {
      text-align: center;
      margin: 16px 0;
      display: none;
    }
    .mic-icon {
      width: 48px;
      height: 48px;
      background: #1f6feb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      box-shadow: 0 0 12px #1f6feb;
      animation: micGlow 1.5s infinite alternate;
    }
    @keyframes micGlow {
      from { box-shadow: 0 0 12px #1f6feb; }
      to { box-shadow: 0 0 24px #1f6feb, 0 0 32px #1f6feb; }
    }
    .mic-label {
      font-size: 13px;
      color: #555;
      margin-top: 8px;
    }
    /* Driver icons */
    .other-driver-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 10px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
    /* Loading overlay */
    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 500;
      color: white;
      font-size: 18px;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Main Menu Panel */
    #menuPanel {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70vh;
      background: white;
      display: none;
      flex-direction: column;
      z-index: 2000;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    #menuPanel.active {
      display: flex;
      transform: translateY(0);
    }
    #menuNav {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #eee;
    }
    .menu-nav-btn {
      flex: 1;
      background: transparent;
      border: none;
      padding: 16px 0;
      font-weight: 600;
      font-size: 15px;
      color: #666;
      cursor: pointer;
    }
    .menu-nav-btn.active {
      color: #1f6feb;
      background: #e8f0fe;
      border-bottom: 3px solid #1f6feb;
    }
    #menuContent {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .current-job-info {
      padding: 20px;
      background: #e8f5e8;
      border-radius: 12px;
      margin-bottom: 20px;
      border-left: 4px solid #28a745;
    }
    .job-detail {
      margin-bottom: 12px;
    }
    .job-label {
      font-weight: 700;
      color: #1f6feb;
      font-size: 15px;
      margin-bottom: 4px;
    }
    .job-value {
      font-size: 17px;
      color: #333;
      word-break: break-word;
    }
    .no-current-job {
      text-align: center;
      padding: 50px 20px;
      color: #666;
    }
    .no-current-job .icon {
      font-size: 60px;
      margin-bottom: 20px;
      opacity: 0.7;
    }
    .job-item {
      padding: 16px;
      border: 1px solid #eee;
      border-radius: 12px;
      margin-bottom: 12px;
      background: #f9f9f9;
      position: relative;
      overflow: hidden;
    }
    .job-item.allocated { border-left: 4px solid #28a745; background: #e8f5e8; }
    .job-item.processing, .job-item.bidding { border-left: 4px solid #1f6feb; background: #e8f0fe; }
    .job-item.completed { border-left: 4px solid #6c757d; background: #f8f9fa; }
    .job-item.lost, .job-item.rejected, .job-item.expired { border-left: 4px solid #dc3545; background: #f8d7da; }
    .job-item.queued { border-left: 4px solid #ffc107; background: #fff8e1; }
    .job-id { font-weight: 700; color: #1f6feb; margin-bottom: 6px; font-size: 16px; }
    .job-pub { font-size: 14px; color: #666; margin-bottom: 6px; }
    .job-phone { font-size: 15px; color: #333; margin-bottom: 6px; }
    .job-status {
      font-size: 12px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 6px;
    }
    .status-processing, .status-bidding { background: #d1e7ff; color: #084298; }
    .status-allocated { background: #d1e7dd; color: #0f5132; }
    .status-completed { background: #e2e3e5; color: #41464b; }
    .status-lost, .status-rejected, .status-expired { background: #f8d7da; color: #842029; }
    .status-queued { background: #fff3cd; color: #856404; }
    /* Swipe-to-delete with trash icon */
    .job-item::after {
      content: "üóëÔ∏è";
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      background: #dc3545;
      color: white;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .job-item.swiping::after {
      opacity: 1;
    }
    #chatMessages {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .message {
      max-width: 85%;
      padding: 14px 16px;
      border-radius: 20px;
      font-size: 15px;
      line-height: 1.5;
      word-wrap: break-word;
    }
    .received { background: #e9ecef; align-self: flex-start; border-bottom-left-radius: 6px; }
    .sent { background: #000; color: white; align-self: flex-end; border-bottom-right-radius: 6px; }
    .message-info {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
    }
    #chatInputContainer {
      display: flex;
      padding: 12px;
      background: white;
      border-top: 1px solid #eee;
    }
    #chatInput {
      flex: 1;
      padding: 14px;
      border: 2px solid #ddd;
      border-radius: 24px;
      font-size: 16px;
      outline: none;
    }
    #chatInput:focus {
      border-color: #1f6feb;
      box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.2);
    }
    #sendBtn {
      background: #000;
      color: #FFD700;
      border: none;
      width: 52px;
      height: 52px;
      border-radius: 50%;
      margin-left: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #chatList {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .contact-item {
      padding: 16px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s;
    }
    .contact-item:hover {
      background: #f8f9fa;
    }
    .contact-name {
      font-weight: 700;
      font-size: 16px;
      margin-bottom: 4px;
    }
    .contact-status {
      font-size: 13px;
      color: #6c757d;
    }
    .contact-badge {
      background: #28a745;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: auto;
    }
    .offline { background: #6c757d; }
    .unread-badge {
      background: #FFD700;
      color: #000;
      border-radius: 12px;
      padding: 4px 8px;
      font-size: 12px;
      margin-left: 8px;
      font-weight: 700;
    }
    .settings-group {
      margin-bottom: 24px;
    }
    .settings-label {
      font-weight: 700;
      margin-bottom: 12px;
      color: #333;
      font-size: 16px;
    }
    .settings-input {
      width: 100%;
      padding: 14px;
      border: 2px solid #ccc;
      border-radius: 12px;
      font-size: 16px;
      box-sizing: border-box;
    }
    .settings-input:focus {
      border-color: #1f6feb;
      outline: none;
    }
    .settings-btn {
      background: #1f6feb;
      color: white;
      border: none;
      padding: 16px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      margin-top: 12px;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(31, 111, 235, 0.3);
    }
    .settings-btn:hover {
      background: #1958c4;
      box-shadow: 0 6px 16px rgba(31, 111, 235, 0.4);
    }
    .settings-info {
      background: #f8f9fa;
      padding: 16px;
      border-radius: 12px;
      font-size: 14px;
      color: #666;
      line-height: 1.5;
    }
    /* Enhanced Taxi Marker */
    .taxi-marker {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="headerBanner">
    <div id="appTitleContainer">
      <div id="appTitle">Black Cab Unite v7.0</div>
      <div id="statusCaption" class="status-available">
        <span class="status-dot"></span> Available
      </div>
    </div>
    <button id="menuBtn">‚ò∞</button>
  </div>
  <!-- Status Dropdown -->
  <div id="statusDropdown" style="
    position: absolute;
    top: 52px;
    left: 16px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1003;
    display: none;
    flex-direction: column;
    min-width: 180px;
  ">
    <div class="status-option" data-status="available" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#28a745; width:12px; height:12px; border-radius:50%;"></span> Available
    </div>
    <div class="status-option" data-status="busy" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#ffc107; width:12px; height:12px; border-radius:50%;"></span> Busy
    </div>
    <div class="status-option" data-status="offline" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px;">
      <span class="status-led" style="background:#dc3545; width:12px; height:12px; border-radius:50%;"></span> Offline
    </div>
    <div id="logOffBtn" style="padding:12px 16px; cursor:pointer; display:flex; align-items:center; gap:10px; border-top:1px solid #eee; color:#dc3545; font-weight:bold;">
      <span>üö™</span> Log Off
    </div>
  </div>
  <div id="status">Initializing...</div>
  <div id="jobPanel">
    <h2>üöï New Job Request</h2>
    <div id="jobInfo">
      <div class="job-info-label">Pickup Location</div>
      <div class="job-info-value" id="pickupLocation">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Name</div>
      <div class="job-info-value" id="customerName">Loading...</div>
      <div class="job-info-label" style="margin-top:12px;">Customer Phone</div>
      <div class="job-info-value" id="customerPhone">Loading...</div>
      <div id="jobTimer">‚è≥ Expires in: <span id="timerSeconds">30</span>s</div>
    </div>
    <div id="micIndicator">
      <div class="mic-icon">üé§</div>
      <div class="mic-label">Say ‚Äúaccept‚Äù or ‚Äúreject‚Äù</div>
    </div>
    <div class="job-actions">
      <button class="job-btn accept-btn" id="acceptBtn">‚úÖ ACCEPT JOB</button>
      <button class="job-btn reject-btn" id="rejectBtn">‚ùå REJECT</button>
    </div>
  </div>
  <div id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div>Loading map...</div>
  </div>
  <div id="menuPanel">
    <div id="menuNav">
      <button class="menu-nav-btn active" data-view="currentJob">üìç Current Job</button>
      <button class="menu-nav-btn" data-view="jobHistory">üìã Job History</button>
      <button class="menu-nav-btn" data-view="chat">üí¨ Chats</button>
      <button class="menu-nav-btn" data-view="settings">‚öôÔ∏è Settings</button>
    </div>
    <div id="menuContent"></div>
  </div>
  <div id="jobWonModal" style="
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  ">
    <div style="
      background: white;
      padding: 30px;
      border-radius: 16px;
      text-align: center;
      max-width: 320px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    ">
      <div style="font-size: 60px; margin-bottom: 16px;">üéâ</div>
      <h2 style="margin: 0 0 12px; color: #1f6feb;">You Won the Job!</h2>
      <p style="margin: 0 0 24px; color: #555;">Get ready to pick up the customer.</p>
      <button id="closeJobWonModal" style="
        background: #1f6feb;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 12px;
        font-weight: bold;
        cursor: pointer;
        width: 100%;
      ">Close</button>
    </div>
  </div>
  <!-- Passenger Preset Popup -->
  <div id="passengerPopup">
    <div id="passengerPopupMsg">Passenger message...</div>
    <div style="display:flex; justify-content:center; gap:10px; margin-top:12px;">
      <button id="presetReply1" class="replyBtn">On my way</button>
      <button id="presetReply2" class="replyBtn">Arrived</button>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script>
  // ===== FIREBASE INIT =====
 const firebaseConfig = {
    apiKey: "AIzaSyBq1aN-KRtRW7S243ef7lz7fnZmlBcuN1s",
    authDomain: "cabunite.firebaseapp.com",
    projectId: "cabunite",
    storageBucket: "cabunite.firebasestorage.app",
    messagingSenderId: "997924656033",
    appId: "1:997924656033:web:1552b9f26a1af0878eb1e0"
  };
  firebase.initializeApp(firebaseConfig);
  const messaging = firebase.messaging();
  // Listen for foreground notifications
  messaging.onMessage((payload) => {
    console.log("üì≤ Foreground message received:", payload);
    if (Notification.permission === 'granted') {
      new Notification(payload.notification?.title || "Taxi Update", {
        body: payload.notification?.body || "You have a new message",
        icon: payload.notification?.icon || '/blackcabunite/icon-192.png'
      });
    }
  });
  // Global vars
  let fcmToken = null;
  let seenJobIds = new Set(); // ‚úÖ Prevent duplicate jobs globally

    document.addEventListener('DOMContentLoaded', () => {
      // ===== Driver Registration =====
      let DRIVER_ID = localStorage.getItem('driver_id');
      function validateDriverId(id) {
        if (!id) return false;
        return /^[a-zA-Z0-9_-]+$/.test(id);
      }
      if(!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
        while (!DRIVER_ID || !validateDriverId(DRIVER_ID)) {
          DRIVER_ID = prompt("Enter your driver name or ID (letters, numbers, hyphens only):");
          if (DRIVER_ID === null) {
            DRIVER_ID = 'driver-' + Math.random().toString(36).substr(2, 8);
            break;
          }
        }
        localStorage.setItem('driver_id', DRIVER_ID);
      }

      // ‚úÖ Initialize seenJobIds from saved jobs
      let driverJobs = JSON.parse(localStorage.getItem(`driver_jobs_${DRIVER_ID}`)) || [];
      let pendingJobs = JSON.parse(localStorage.getItem(`pending_jobs_${DRIVER_ID}`)) || [];
      seenJobIds = new Set([...driverJobs.map(j => j.job), ...pendingJobs.map(p => p.job)]);

      let driverPresence = localStorage.getItem('driver_presence') || 'available';
      let ttsInitialized = false;
      function initTTS() {
        if (ttsInitialized || !('speechSynthesis' in window)) return;
        const utterance = new SpeechSynthesisUtterance('');
        utterance.volume = 0;
        speechSynthesis.speak(utterance);
        ttsInitialized = true;
      }
      document.body.addEventListener('click', initTTS, { once: true });
      document.body.addEventListener('touchstart', initTTS, { once: true });
      const MQTT_BROKER = "wss://broker.hivemq.com:8884/mqtt";
      const REQUEST_TOPIC = "pubs/requests/+";
      const LOCATION_TOPIC = `drivers/${DRIVER_ID}/location`;
      const DRIVERS_LOCATION_TOPIC = "drivers/+/location";
      const CHAT_GROUP_TOPIC = "chat/group";
      const CHAT_PRIVATE_TOPIC = `chat/private/${DRIVER_ID}/+`;
      const JOB_RESULT_TOPIC = `jobs/+/result/${DRIVER_ID}`;
      // ===== PASSENGER PRESET HANDLING =====
      function handlePassengerPreset(data) {
        console.log("üí¨ Passenger preset received:", data);
        const preset = data?.presetType || "Unknown";
        const passengerMsg =
          preset === "where_are_you" ? "Passenger asks: Where are you?" :
          preset === "cancel_ride" ? "Passenger wants to cancel the ride." :
          preset === "call_driver" ? "Passenger is trying to call you." :
          `Passenger message: ${preset}`;
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance(passengerMsg);
          utterance.lang = 'en-GB';
          utterance.rate = 1;
          speechSynthesis.cancel();
          speechSynthesis.speak(utterance);
        }
        showPassengerPopup(passengerMsg, data);
      }
      function showPassengerPopup(msg, data) {
        const popup = document.getElementById('passengerPopup');
        const msgEl = document.getElementById('passengerPopupMsg');
        msgEl.textContent = msg;
        popup.style.display = 'block';
        setTimeout(() => { popup.style.display = 'none'; }, 15000);
        document.getElementById('presetReply1').onclick = () => sendPresetReply('on_my_way', data);
        document.getElementById('presetReply2').onclick = () => sendPresetReply('arrived', data);
      }
      function sendPresetReply(type, data) {
        const payload = {
          type: 'driver_preset_reply',
          replyType: type,
          driverId: DRIVER_ID,
          jobId: data?.jobId || null,
          timestamp: new Date().toISOString()
        };
        client.publish('server/preset_replies', JSON.stringify(payload));
        document.getElementById('passengerPopup').style.display = 'none';
      }
      // ===== DEDUPLICATION HELPER =====
      function dedupeJobs(jobs) {
        const seen = new Set();
        return jobs.filter(job => {
          if (seen.has(job.job)) return false;
          seen.add(job.job);
          return true;
        });
      }
      // Load and dedupe jobs (already done above via seenJobIds)
      driverJobs = dedupeJobs(driverJobs);
      pendingJobs = dedupeJobs(pendingJobs);

      let driverCoords = null;
      let map = null;
      let driverMarker = null;
      let pickupMarker = null;
      let routeLine = null;
      let client = null;
      let isMenuOpen = false;
      let currentView = 'currentJob';
      let gpsWatchId = null;
      let wakeLock = null;
      const otherDrivers = {};
      const driverStatus = {};
      const chatMessages = { group: JSON.parse(localStorage.getItem(`chat_group_${DRIVER_ID}`)) || [] };
      const unreadCounts = { group: 0 };
      let maxRadius = parseFloat(localStorage.getItem('max_radius_km') || '10');
      let isJobActive = false;
      let currentChat = 'group';
      let jobTimerInterval = null;
      let jobWakeLock = null;
      const statusEl = document.getElementById('status');
      const jobPanel = document.getElementById('jobPanel');
      const pickupLocation = document.getElementById('pickupLocation');
      const customerName = document.getElementById('customerName');
      const customerPhone = document.getElementById('customerPhone');
      const menuPanel = document.getElementById('menuPanel');
      const menuContent = document.getElementById('menuContent');
      const menuNavBtns = document.querySelectorAll('.menu-nav-btn');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const micIndicator = document.getElementById('micIndicator');

      // ===== ENHANCED TAXI MARKER =====
      const BLACK_CAB_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 58 36" width="58" height="36">
  <rect x="4" y="14" width="50" height="14" rx="3" ry="3" fill="#000"/>
  <path d="M18 14v-4c0-3 2-5 5-5h12c3 0 5 2 5 5v4h-22z" fill="#000"/>
  <rect x="25" y="4" width="8" height="3" rx="1" fill="#FFD700" stroke="#000" stroke-width="0.5"/>
  <text x="29" y="6.6" text-anchor="middle" font-size="2.2" font-weight="bold" fill="#000" font-family="Arial, sans-serif">TAXI</text>
  <rect x="21" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <rect x="31" y="7" width="6" height="6" rx="1" fill="#fff"/>
  <circle cx="15" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
  <circle cx="43" cy="28" r="4" fill="#fff" stroke="#000" stroke-width="1"/>
</svg>
`;
      function createBlackCabIcon(heading = 0) {
        const div = document.createElement('div');
        div.innerHTML = BLACK_CAB_SVG;
        const svg = div.firstElementChild;
        svg.style.transform = `rotate(${heading}deg)`;
        svg.style.transformOrigin = 'center';
        return L.divIcon({
          html: svg.outerHTML,
          iconSize: [58, 36],
          iconAnchor: [29, 18],
          className: 'taxi-marker'
        });
      }
      function savePendingJobs() {
        localStorage.setItem(`pending_jobs_${DRIVER_ID}`, JSON.stringify(pendingJobs));
      }
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const œÜ1 = (lat1 * Math.PI) / 180;
        const œÜ2 = (lat2 * Math.PI) / 180;
        const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
        const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;
        const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
      function updateDriverMarker(lat, lng, headingValue) {
        if (!driverMarker) return;
        driverMarker.setLatLng([lat, lng]);
        driverMarker.setIcon(createBlackCabIcon(headingValue));
      }
      function updateMapCenter(lat, lng) {
        if (!map) return;
        const center = map.getCenter();
        const dist = calculateDistance(center.lat, center.lng, lat, lng);
        if (dist > 50) map.panTo([lat, lng]);
      }
      let lastPublish = 0;
      let lastPublishCoords = null;
      function publishLocationThrottled(gpsData) {
        const now = Date.now();
        if (!lastPublishCoords ||
            calculateDistance(lastPublishCoords.lat, lastPublishCoords.lng, gpsData.lat, gpsData.lng) > 5 ||
            now - lastPublish > 3000) {
          client.publish(LOCATION_TOPIC, JSON.stringify({
            driver: DRIVER_ID,
            lat: gpsData.lat,
            lng: gpsData.lng,
            status: 'idle',
            ts: now,
            heading: Math.round(gpsData.heading)
          }));
          lastPublish = now;
          lastPublishCoords = { lat: gpsData.lat, lng: gpsData.lng };
        }
      }
      async function requestWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
          }
        } catch (err) {
          console.warn('Wake Lock failed:', err);
        }
      }
      function releaseWakeLock() {
        if (wakeLock) {
          wakeLock.release();
          wakeLock = null;
        }
      }
      function initMapImmediately() {
        loadingOverlay.style.display = 'none';
        const defaultCenter = [52.4068, -1.5197];
        map = L.map('map').setView(defaultCenter, 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
          maxZoom: 19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
        driverMarker = L.marker(defaultCenter, {
          title: "Location Initializing...",
          icon: createBlackCabIcon(0)
        }).addTo(map);
        statusEl.innerHTML = '<span class="gps-source gps-poor"></span>Map loaded. Getting location...';
        initGPS();
      }
      function initGPS() {
        if (!('geolocation' in navigator)) {
          alert("Geolocation not supported.");
          statusEl.innerHTML = '<span class="gps-source gps-poor"></span>Geolocation not supported.';
          connectMQTT();
          return;
        }
        statusEl.innerHTML = '<span class="gps-source gps-poor"></span>Searching for GPS...';
        requestWakeLock();
        if (gpsWatchId) {
          navigator.geolocation.clearWatch(gpsWatchId);
        }
        gpsWatchId = navigator.geolocation.watchPosition(
          pos => {
            const gpsData = {
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              speed: pos.coords.speed,
              accuracy: pos.coords.accuracy || 50,
              heading: pos.coords.heading || 0,
              timestamp: pos.timestamp || Date.now()
            };
            driverCoords = gpsData;
            updateDriverMarker(gpsData.lat, gpsData.lng, gpsData.heading);
            updateMapCenter(gpsData.lat, gpsData.lng);
            if (currentJob && routeLine) {
              routeLine.setLatLngs([[gpsData.lat, gpsData.lng], [currentJob.lat, currentJob.lng]]);
            }
            publishLocationThrottled(gpsData);
            let statusClass = 'gps-gps';
            if (gpsData.accuracy > 50) statusClass = 'gps-poor';
            else if (gpsData.accuracy > 20) statusClass = 'gps-network';
            statusEl.innerHTML = `
              <span class="gps-source ${statusClass}"></span>
              GPS: ${gpsData.lat.toFixed(5)}, ${gpsData.lng.toFixed(5)} | 
              Acc: ¬±${Math.round(gpsData.accuracy)}m | 
              Speed: ${gpsData.speed ? Math.round(gpsData.speed * 3.6) : '--'} km/h
            `;
          },
          err => {
            statusEl.textContent = "GPS error: " + err.message;
            setTimeout(() => {
              if (driverPresence !== 'offline') {
                initGPS();
              }
            }, 5000);
          },
          { enableHighAccuracy: true, maximumAge: 0, timeout: 8000 }
        );
        connectMQTT();
      }
      // ===== ROBUST VOICE INTERACTION (STT + TTS) =====
      let speechRecognition = null;
      let isSpeaking = false;
      let voiceAttemptCount = 0;
      const MAX_VOICE_ATTEMPTS = 3;
      const LISTEN_TIMEOUT_MS = 8000;
      const TTS_TO_MIC_DELAY_MS = 600;
      function showMicIndicator() {
        micIndicator.style.display = 'block';
      }
      function hideMicIndicator() {
        micIndicator.style.display = 'none';
      }
      function speakFeedback(message, onDone = null) {
        if (!('speechSynthesis' in window)) {
          if (onDone) setTimeout(onDone, 100);
          return;
        }
        isSpeaking = true;
        stopVoiceListener();
        const utterance = new SpeechSynthesisUtterance(message);
        utterance.lang = 'en-GB';
        utterance.rate = 0.9;
        utterance.onend = () => {
          isSpeaking = false;
          if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
        };
        utterance.onerror = () => {
          isSpeaking = false;
          if (onDone) setTimeout(onDone, TTS_TO_MIC_DELAY_MS);
        };
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
      }
      function startVoiceListener() {
        if (isSpeaking || speechRecognition) return;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          console.warn("SpeechRecognition not supported");
          return;
        }
        speechRecognition = new SpeechRecognition();
        speechRecognition.lang = 'en-US';
        speechRecognition.continuous = false;
        speechRecognition.interimResults = false;
        let timeoutId = null;
        speechRecognition.onstart = () => {
          showMicIndicator();
          timeoutId = setTimeout(() => {
            if (speechRecognition) speechRecognition.stop();
          }, LISTEN_TIMEOUT_MS);
        };
        speechRecognition.onresult = (event) => {
          clearTimeout(timeoutId);
          const transcript = event.results[0][0].transcript.toLowerCase().trim();
          console.log("üé§ Heard:", transcript);
          if (/\baccept\b/.test(transcript) && !/\breject\b/.test(transcript)) {
            voiceAttemptCount = 0;
            respondToJob(true);
            speakFeedback("Job accepted. Thank you.");
          } else if (/\breject\b/.test(transcript)) {
            voiceAttemptCount = 0;
            respondToJob(false);
            speakFeedback("Job rejected. Understood.");
          } else {
            voiceAttemptCount++;
            stopVoiceListener();
            promptForVoiceResponse();
          }
        };
        speechRecognition.onerror = (e) => {
          clearTimeout(timeoutId);
          console.error("Voice error:", e.error);
          stopVoiceListener();
          voiceAttemptCount++;
          if (voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
            setTimeout(promptForVoiceResponse, 1000);
          } else {
            speakFeedback("Voice system error. Please use the buttons.");
          }
        };
        speechRecognition.onend = () => {
          clearTimeout(timeoutId);
          hideMicIndicator();
          speechRecognition = null;
          if (isJobActive && jobPanel.style.display === 'block' && voiceAttemptCount > 0 && voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
            setTimeout(promptForVoiceResponse, 800);
          }
        };
        try {
          speechRecognition.start();
        } catch (err) {
          console.error("Failed to start speech recognition:", err);
          speechRecognition = null;
          voiceAttemptCount++;
          if (voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
            setTimeout(promptForVoiceResponse, 1000);
          }
        }
      }
      function stopVoiceListener() {
        hideMicIndicator();
        if (speechRecognition) {
          speechRecognition.abort();
          speechRecognition = null;
        }
      }
      function promptForVoiceResponse() {
        if (isSpeaking || !isJobActive) return;
        if (voiceAttemptCount === 0) {
          setTimeout(startVoiceListener, TTS_TO_MIC_DELAY_MS);
        } else if (voiceAttemptCount < MAX_VOICE_ATTEMPTS) {
          speakFeedback("Did not hear you. Please say ‚Äòaccept‚Äô or ‚Äòreject‚Äô.", () => {
            startVoiceListener();
          });
        } else {
          speakFeedback("Let me repeat the job.", () => {
            const job = currentJob;
            if (job) {
              const utterance = new SpeechSynthesisUtterance(
                `Pickup at ${job.pubName}. Customer: ${job.customerName || 'name not given'}. Phone: ${job.customerPhone || 'not provided'}`
              );
              utterance.lang = 'en-GB';
              utterance.rate = 0.9;
              utterance.onend = () => {
                voiceAttemptCount = 0;
                setTimeout(promptForVoiceResponse, TTS_TO_MIC_DELAY_MS);
              };
              speechSynthesis.speak(utterance);
            }
          });
        }
      }
      function cleanupJob() {
        if (jobTimerInterval) {
          clearInterval(jobTimerInterval);
          jobTimerInterval = null;
        }
        jobPanel.style.display = 'none';
        stopVoiceListener();
        speechSynthesis.cancel();
        currentJob = null;
        isJobActive = false;
        if (pickupMarker) { map.removeLayer(pickupMarker); pickupMarker = null; }
        if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
        if (jobWakeLock) {
          jobWakeLock.release();
          jobWakeLock = null;
        }
      }
      function showJobPanel(job) {
        if (jobTimerInterval) {
          clearInterval(jobTimerInterval);
          jobTimerInterval = null;
        }
        stopVoiceListener();
        currentJob = null;
        isJobActive = true;
        currentJob = job;
        jobPanel.style.display = 'block';
        pickupLocation.textContent = `${job.pubName} (${job.lat.toFixed(5)}, ${job.lng.toFixed(5)})`;
        customerName.textContent = job.customerName || 'Not provided';
        customerPhone.textContent = job.customerPhone || 'Not provided';
        const timerEl = document.getElementById('jobTimer');
        const secondsEl = document.getElementById('timerSeconds');
        timerEl.style.display = 'none';
        if ('speechSynthesis' in window) {
          const utterance = new SpeechSynthesisUtterance(
            `New job! Pickup at ${job.pubName}. Customer: ${job.customerName || 'name not given'}. Phone: ${job.customerPhone || 'not provided'}`
          );
          utterance.lang = 'en-GB';
          utterance.rate = 0.9;
          utterance.onend = () => {
            timerEl.style.display = 'block';
            secondsEl.textContent = '30';
            let secondsLeft = 30;
            jobTimerInterval = setInterval(() => {
              secondsLeft--;
              secondsEl.textContent = secondsLeft;
              if (secondsLeft <= 0) {
                clearInterval(jobTimerInterval);
                jobTimerInterval = null;
                cleanupJob();
                processNextJob();
              }
            }, 1000);
            voiceAttemptCount = 0;
            promptForVoiceResponse();
          };
          speechSynthesis.cancel();
          speechSynthesis.speak(utterance);
        } else {
          timerEl.style.display = 'block';
          secondsEl.textContent = '30';
          let secondsLeft = 30;
          jobTimerInterval = setInterval(() => {
            secondsLeft--;
            secondsEl.textContent = secondsLeft;
            if (secondsLeft <= 0) {
              clearInterval(jobTimerInterval);
              jobTimerInterval = null;
              cleanupJob();
              processNextJob();
            }
          }, 1000);
          voiceAttemptCount = 0;
          promptForVoiceResponse();
        }
        async function requestJobWakeLock() {
          if ('wakeLock' in navigator) {
            try {
              jobWakeLock = await navigator.wakeLock.request('screen');
              jobWakeLock.addEventListener('release', () => { jobWakeLock = null; });
            } catch (err) {
              console.warn('Job Wake Lock failed:', err);
            }
          }
        }
        requestJobWakeLock();
      }
      function processNextJob() {
        if (isJobActive || pendingJobs.length === 0 || driverPresence !== 'available') return;
        const job = pendingJobs.shift();
        savePendingJobs();
        showJobPanel(job);
      }
      function respondToJob(accepted, job = currentJob) {
        if (!job || !client) return;
        if (jobTimerInterval) {
          clearInterval(jobTimerInterval);
          jobTimerInterval = null;
        }
        stopVoiceListener();
        speechSynthesis.cancel();
        if (accepted) {
          const payload = {
            job: job.job,
            driver: DRIVER_ID,
            status: "bidding",
            lat: driverCoords?.lat || job.lat,
            lng: driverCoords?.lng || job.lng,
            ts: Date.now()
          };
          client.publish(`jobs/${job.job}/status`, JSON.stringify(payload));
          statusEl.innerHTML = '‚úÖ Bid sent';
          updateJobStatus(job.job, 'bidding');
        } else {
          const payload = { job: job.job, driver: DRIVER_ID, status: "rejected", ts: Date.now() };
          client.publish(`jobs/${job.job}/status`, JSON.stringify(payload));
          statusEl.innerHTML = '‚ùå Job rejected';
          updateJobStatus(job.job, 'rejected');
        }
        if (job === currentJob) {
          cleanupJob();
          setTimeout(() => processNextJob(), 2000);
        } else {
          showJobPanel(job);
        }
      }
      function saveJobs() {
        localStorage.setItem(`driver_jobs_${DRIVER_ID}`, JSON.stringify(driverJobs));
      }
      function addJobToHistory(jobData, initialStatus = 'queued') {
        const job = {
          ...jobData,
          status: initialStatus,
          timestamp: Date.now(),
          driver: DRIVER_ID
        };
        const existingIndex = driverJobs.findIndex(j => j.job === job.job);
        if (existingIndex >= 0) {
          driverJobs[existingIndex] = job;
        } else {
          driverJobs.unshift(job);
          if (driverJobs.length > 50) {
            driverJobs = driverJobs.slice(0, 50);
          }
        }
        saveJobs();
        if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
        if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
      }
      function updateJobStatus(jobId, status) {
        const jobIndex = driverJobs.findIndex(j => j.job === jobId);
        if (jobIndex >= 0) {
          driverJobs[jobIndex].status = status;
          saveJobs();
          if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
          if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
        }
      }
      function renderCurrentJob() {
        const allocatedJobs = driverJobs.filter(job => job.status === 'allocated');
        if (allocatedJobs.length === 0) {
          menuContent.innerHTML = `
            <div class="no-current-job">
              <div class="icon">üöï</div>
              <div>No active jobs</div>
              <div style="font-size: 14px; color: #666; margin-top: 12px;">You'll see your current job here once allocated</div>
            </div>
          `;
          return;
        }
        const current = allocatedJobs[0];
        menuContent.innerHTML = `
          <div class="current-job-info">
            <div class="job-detail">
              <div class="job-label">Job ID</div>
              <div class="job-value">${current.job}</div>
            </div>
            <div class="job-detail">
              <div class="job-label">Pub</div>
              <div class="job-value">${current.pubName}</div>
            </div>
            <div class="job-detail">
              <div class="job-label">Customer Name</div>
              <div class="job-value">üë§ ${current.customerName || '‚Äî'}</div>
            </div>
            <div class="job-detail">
              <div class="job-label">Customer Phone</div>
              <div class="job-value">üìû ${current.customerPhone}</div>
            </div>
            <div class="job-detail">
              <div class="job-label">Pickup Location</div>
              <div class="job-value">üìç ${current.lat.toFixed(5)}, ${current.lng.toFixed(5)}</div>
            </div>
            <div class="job-detail">
              <div class="job-label">Status</div>
              <div class="job-value">
                <span class="job-status status-allocated">ALLOCATED</span>
              </div>
            </div>
            <div class="job-detail">
              <div class="job-label">Received</div>
              <div class="job-value">${new Date(current.timestamp).toLocaleString()}</div>
            </div>
          </div>
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <button class="settings-btn" id="navToPickupBtn">üß≠ Navigate to Pickup</button>
            <button class="settings-btn" id="callCustomerBtn" style="background:#28a745;">üìû Call Customer</button>
            <button class="settings-btn" onclick="markJobCompleted('${current.job}')">Mark as Completed</button>
          </div>
        `;
        document.getElementById('navToPickupBtn').addEventListener('click', () => {
          const url = `https://www.google.com/maps/dir/?api=1&destination=${current.lat},${current.lng}`;
          window.open(url, '_blank');
        });
        document.getElementById('callCustomerBtn').addEventListener('click', () => {
          const phone = current.customerPhone.replace(/\D/g, '');
          if (phone) {
            window.location.href = `tel:${phone}`;
          } else {
            alert("Customer phone number not available.");
          }
        });
      }
      function renderJobHistory() {
        menuContent.innerHTML = '';
        if (driverJobs.length === 0) {
          menuContent.innerHTML = '<div style="text-align:center; padding:50px 20px; color:#666;">No jobs in history</div>';
          return;
        }
        const jobsContainer = document.createElement('div');
        jobsContainer.id = 'jobHistoryContent';
        driverJobs.forEach(job => {
          const jobEl = document.createElement('div');
          jobEl.className = `job-item ${job.status}`;
          jobEl.dataset.jobId = job.job;
          const date = new Date(job.timestamp);
          const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
          const dateStr = date.toLocaleDateString();
          let actionButtons = '';
          if (job.status === 'queued') {
            actionButtons = `
              <div style="display:flex; gap:8px; margin-top:12px;">
                <button class="settings-btn" style="flex:1; padding:8px; font-size:14px;" data-action="view" data-jobid="${job.job}">
                  View Details
                </button>
                <button class="settings-btn" style="flex:1; padding:8px; font-size:14px; background:#28a745;" data-action="bid" data-jobid="${job.job}">
                  üí∞ Bid Now
                </button>
              </div>
            `;
          }
          jobEl.innerHTML = `
            <div class="job-id">${job.job}</div>
            <div class="job-pub">Pub: ${job.pubName}</div>
            <div class="job-phone">üë§ ${job.customerName || '‚Äî'}</div>
            <div class="job-phone">üìû ${job.customerPhone}</div>
            <div class="job-phone">üìç ${job.lat.toFixed(5)}, ${job.lng.toFixed(5)}</div>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
              <span class="job-status status-${job.status}">${job.status.toUpperCase()}</span>
              <span style="font-size:12px; color:#666;">${dateStr} ${timeStr}</span>
            </div>
            ${actionButtons}
          `;
          jobsContainer.appendChild(jobEl);
        });
        menuContent.appendChild(jobsContainer);
        menuContent.querySelectorAll('[data-action]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            const jobId = e.target.dataset.jobid;
            const job = pendingJobs.find(j => j.job === jobId) || 
                        driverJobs.find(j => j.job === jobId && j.status === 'queued');
            if (!job) {
              alert("Job no longer available.");
              return;
            }
            if (action === 'view') {
              if (isJobActive) {
                alert("Please finish the current job first.");
                return;
              }
              showJobPanel(job);
            } else if (action === 'bid') {
              respondToJob(true, job);
            }
          });
        });
        attachSwipeToDelete();
      }
      function attachSwipeToDelete() {
        const items = document.querySelectorAll('#jobHistoryContent .job-item');
        items.forEach(item => {
          let startX = 0;
          let currentX = 0;
          let isSwiping = false;
          const handleStart = (clientX) => {
            startX = clientX;
            currentX = startX;
            isSwiping = true;
            item.classList.remove('swipe-delete');
          };
          const handleMove = (clientX) => {
            if (!isSwiping) return;
            currentX = clientX;
            const diff = currentX - startX;
            if (diff > 0) {
              item.classList.add('swiping');
              item.style.transform = `translateX(${Math.min(diff, 80)}px)`;
            }
          };
          const handleEnd = () => {
            if (!isSwiping) return;
            const diff = currentX - startX;
            item.classList.remove('swiping');
            item.style.transform = '';
            isSwiping = false;
            if (diff > 50) {
              const jobId = item.dataset.jobId;
              if (confirm("üóëÔ∏è Delete this job permanently?")) {
                item.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                item.style.transform = 'translateX(100vw)';
                item.style.opacity = '0';
                setTimeout(() => {
                  driverJobs = driverJobs.filter(job => job.job !== jobId);
                  saveJobs();
                  if (isMenuOpen && currentView === 'jobHistory') {
                    renderJobHistory();
                  }
                }, 300);
              }
            }
          };
          item.addEventListener('touchstart', e => handleStart(e.touches[0].clientX));
          item.addEventListener('touchmove', e => handleMove(e.touches[0].clientX));
          item.addEventListener('touchend', handleEnd);
          item.addEventListener('mousedown', e => handleStart(e.clientX));
          item.addEventListener('mousemove', e => handleMove(e.clientX));
          item.addEventListener('mouseup', handleEnd);
          item.addEventListener('mouseleave', () => {
            if (isSwiping) {
              item.classList.remove('swiping');
              item.style.transform = '';
              isSwiping = false;
            }
          });
          item.addEventListener('selectstart', e => e.preventDefault());
        });
      }
      function renderChatView() {
        if (!currentChat) {
          currentChat = 'group';
          unreadCounts.group = 0;
          updateChatList();
        }
        menuContent.innerHTML = `
          <div id="chatContent" style="height:100%; display:flex; flex-direction:column;">
            <div id="chatList" style="flex:1; overflow-y:auto; padding:8px;">
              <div class="contact-item" data-chat="group">
                <div class="other-driver-icon" style="background:#6f42c1;">GC</div>
                <div>
                  <div class="contact-name">Group Chat</div>
                  <div class="contact-status">All drivers</div>
                </div>
                ${unreadCounts.group > 0 ? `<div class="unread-badge">${unreadCounts.group}</div>` : ''}
              </div>
            </div>
            <div id="chatMessages" style="flex:1; padding:16px; overflow-y:auto; display:none; flex-direction:column; gap:12px;"></div>
            <div id="chatInputContainer" style="padding:12px; background:white; border-top:1px solid #eee; display:none;">
              <input type="text" id="chatInput" placeholder="Type a message..." autocomplete="off" style="flex:1; padding:14px; border:2px solid #ddd; border-radius:24px; font-size:16px;">
              <button id="sendBtn" style="background:#000; color:#FFD700; border:none; width:52px; height:52px; border-radius:50%; margin-left:12px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:bold; font-size:20px; box-shadow:0 2px 8px rgba(0,0,0,0.2);">‚û§</button>
            </div>
          </div>
        `;
        const chatListEl = document.getElementById('chatList');
        if (chatListEl) {
          chatListEl.addEventListener('click', (e) => {
            const contact = e.target.closest('.contact-item');
            if (contact) {
              e.stopPropagation();
              openChat(contact.dataset.chat);
            }
          });
        }
        openChat('group');
      }
      function openChat(chatId) {
        currentChat = chatId;
        const chatList = document.getElementById('chatList');
        const chatMessages = document.getElementById('chatMessages');
        const chatInputContainer = document.getElementById('chatInputContainer');
        if (chatList) chatList.style.display = 'none';
        if (chatMessages) chatMessages.style.display = 'flex';
        if (chatInputContainer) chatInputContainer.style.display = 'flex';
        unreadCounts[chatId] = 0;
        updateChatList();
        renderChatMessages();
        const chatInput = document.getElementById('chatInput');
        if (chatInput) chatInput.focus();
        const sendBtn = document.getElementById('sendBtn');
        if (sendBtn) {
          sendBtn.onclick = sendChatMessage;
        }
        if (chatInput) {
          chatInput.onkeypress = (e) => {
            if (e.key === 'Enter') sendChatMessage();
          };
        }
      }
      function renderChatMessages() {
        const chatMessagesEl = document.getElementById('chatMessages');
        if (!chatMessagesEl) return;
        chatMessagesEl.innerHTML = '';
        const messages = chatMessages[currentChat] || [];
        messages.forEach(msg => {
          const text = typeof msg.text === 'string' ? msg.text : '[No message]';
          const sender = typeof msg.sender === 'string' ? msg.sender : 'unknown';
          const time = msg.timestamp
            ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
            : '--:--';
          const messageEl = document.createElement('div');
          messageEl.className = `message ${sender === DRIVER_ID ? 'sent' : 'received'}`;
          messageEl.innerHTML = `
            ${text}
            <div class="message-info">
              <span>${sender}</span>
              <span>${time}</span>
            </div>
          `;
          chatMessagesEl.appendChild(messageEl);
        });
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }
      function updateChatList() {
        const chatList = document.getElementById('chatList');
        if (!chatList) return;
        let html = `
          <div class="contact-item" data-chat="group">
            <div class="other-driver-icon" style="background:#6f42c1;">GC</div>
            <div>
              <div class="contact-name">Group Chat</div>
              <div class="contact-status">All drivers</div>
            </div>
            ${unreadCounts.group > 0 ? `<div class="unread-badge">${unreadCounts.group}</div>` : ''}
          </div>
        `;
        Object.keys(otherDrivers).forEach(driverId => {
          const isOnline = (Date.now() - (driverStatus[driverId] || 0)) < 60000;
          const color = getColorForDriver(driverId);
          const unread = unreadCounts[driverId] || 0;
          html += `
            <div class="contact-item" data-chat="${driverId}">
              <div class="other-driver-icon" style="background:${color}">${driverId.substring(0,2).toUpperCase()}</div>
              <div>
                <div class="contact-name">${driverId}</div>
                <div class="contact-status">${isOnline ? 'Online' : 'Offline'}</div>
              </div>
              ${unread > 0 ? `<div class="unread-badge">${unread}</div>` : ''}
            </div>
          `;
        });
        chatList.innerHTML = html;
      }
      function sendChatMessage() {
        const chatInput = document.getElementById('chatInput');
        if (!chatInput || !currentChat) return;
        const text = chatInput.value.trim();
        if (!text) return;
        const payload = { sender: DRIVER_ID, text, timestamp: Date.now() };
        if (currentChat === 'group') {
          client.publish(CHAT_GROUP_TOPIC, JSON.stringify(payload));
        } else {
          client.publish(`chat/private/${currentChat}/${DRIVER_ID}`, JSON.stringify(payload));
        }
        addMessage(currentChat, DRIVER_ID, text);
        chatInput.value = '';
      }
      function addMessage(chatId, sender, text, timestamp = Date.now()) {
        if (!chatMessages[chatId]) {
          chatMessages[chatId] = [];
          unreadCounts[chatId] = 0;
        }
        chatMessages[chatId].push({ sender, text, timestamp });
        if (chatMessages[chatId].length > 50) {
          chatMessages[chatId] = chatMessages[chatId].slice(-50);
        }
        if (!isMenuOpen || currentView !== 'chat' || currentChat !== chatId) {
          unreadCounts[chatId] = (unreadCounts[chatId] || 0) + 1;
        }
        saveChatMessages();
        updateChatList();
        if (isMenuOpen && currentView === 'chat' && currentChat === chatId) {
          renderChatMessages();
        }
      }
      function saveChatMessages() {
        localStorage.setItem(`chat_group_${DRIVER_ID}`, JSON.stringify(chatMessages.group || []));
        if (currentChat && currentChat !== 'group') {
          localStorage.setItem(`chat_${currentChat}_${DRIVER_ID}`, JSON.stringify(chatMessages[currentChat] || []));
        }
      }
      function renderSettingsView() {
        menuContent.innerHTML = `
          <div class="settings-group">
            <div class="settings-label">Driver ID</div>
            <input type="text" id="driverIdInput" class="settings-input" placeholder="Enter your driver ID" value="${DRIVER_ID}">
            <button class="settings-btn" id="saveDriverIdBtn">Save Driver ID</button>
            <div class="settings-info">
              Your current ID: <span id="currentDriverId">${DRIVER_ID}</span>
            </div>
          </div>
          <div class="settings-group">
            <div class="settings-label">Max Job Radius (km)</div>
            <input type="number" id="maxRadiusInput" class="settings-input" value="${maxRadius}" min="1" max="50" step="1">
            <button class="settings-btn" id="saveRadiusBtn">Save Radius</button>
          </div>
          <div class="settings-group">
            <div class="settings-label">Clear Job History</div>
            <button class="settings-btn" id="clearJobsBtn" style="background:#dc3545;">Clear All Jobs</button>
          </div>
        `;
        document.getElementById('saveDriverIdBtn').addEventListener('click', () => {
          const newId = document.getElementById('driverIdInput').value.trim();
          if (!newId) {
            alert("Please enter a driver ID");
            return;
          }
          if (!validateDriverId(newId)) {
            alert("Invalid driver ID. Use only letters, numbers, hyphens, and underscores.");
            return;
          }
          localStorage.setItem('driver_id', newId);
          DRIVER_ID = newId;
          document.getElementById('currentDriverId').textContent = newId;
          if (client) {
            client.end();
            setTimeout(() => connectMQTT(), 1000);
          }
          statusEl.innerHTML = `<span class="gps-source gps-gps"></span>‚úÖ Driver ID updated to: ${newId}`;
        });
        document.getElementById('saveRadiusBtn').addEventListener('click', () => {
          const val = document.getElementById('maxRadiusInput').value;
          const radius = parseFloat(val);
          if (isNaN(radius) || radius < 1 || radius > 50) {
            alert("Please enter a radius between 1 and 50 km");
            return;
          }
          maxRadius = radius;
          localStorage.setItem('max_radius_km', radius.toString());
          statusEl.innerHTML = `‚úÖ Max radius set to ${radius} km`;
        });
        document.getElementById('clearJobsBtn').addEventListener('click', () => {
          if (confirm("Are you sure you want to clear all job history?")) {
            driverJobs = [];
            pendingJobs = [];
            saveJobs();
            savePendingJobs();
            if (isMenuOpen && currentView === 'jobHistory') renderJobHistory();
            if (isMenuOpen && currentView === 'currentJob') renderCurrentJob();
            statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚úÖ Job history cleared';
          }
        });
      }
      window.markJobCompleted = function(jobId) {
        const payload = { job: jobId, driver: DRIVER_ID, status: "completed", ts: Date.now() };
        client.publish(`jobs/${jobId}/status`, JSON.stringify(payload));
        updateJobStatus(jobId, 'completed');
        statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job marked as completed';
      };
      function getColorForDriver(driverId) {
        let hash = 0;
        for (let i = 0; i < driverId.length; i++) {
          hash = driverId.charCodeAt(i) + ((hash << 5) - hash);
        }
        const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        return "#" + "00000".substring(0, 6 - c.length) + c;
      }
      function setDriverPresence(status) {
        if (!['available', 'busy', 'offline'].includes(status)) return;
        driverPresence = status;
        localStorage.setItem('driver_presence', status);
        const caption = document.getElementById('statusCaption');
        caption.className = `status-${status}`;
        caption.innerHTML = `
          <span class="status-dot"></span> 
          ${status.charAt(0).toUpperCase() + status.slice(1)}
        `;
        if (status === 'offline' && gpsWatchId) {
          navigator.geolocation.clearWatch(gpsWatchId);
          gpsWatchId = null;
        } else if (status !== 'offline' && !gpsWatchId) {
          initGPS();
        } else if (status !== 'offline' && driverCoords) {
          publishLocationThrottled(driverCoords);
        }
      }
      function handleLogOff() {
        setDriverPresence('offline');
        document.getElementById('statusDropdown').style.display = 'none';
        statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚úÖ You are now logged off (offline)';
      }
      function connectMQTT() {
        statusEl.innerHTML = `<span class="gps-source gps-poor"></span>Connecting to MQTT as: ${DRIVER_ID}`;
        client = mqtt.connect(MQTT_BROKER, {
          clientId: 'driver-' + DRIVER_ID + '-' + Math.random().toString(16).substr(2,8),
          clean: true,
          reconnectPeriod: 1000
        });
        client.on('connect', () => {
          statusEl.innerHTML = `<span class="gps-source gps-gps"></span>Connected as: ${DRIVER_ID}`;
          client.subscribe(REQUEST_TOPIC);
          client.subscribe(DRIVERS_LOCATION_TOPIC);
          client.subscribe(CHAT_GROUP_TOPIC);
          client.subscribe(CHAT_PRIVATE_TOPIC);
          client.subscribe(JOB_RESULT_TOPIC);
          client.subscribe(`drivers/${DRIVER_ID}/presets`); // üëà NEW
          publishFcmToken(); // ‚úÖ Publish FCM token on connect
          client.publish(`drivers/${DRIVER_ID}/status`, JSON.stringify({
            driver: DRIVER_ID,
            status: driverPresence,
            ts: Date.now()
          }));
          if (driverCoords) {
            publishLocationThrottled(driverCoords);
          }
          setInterval(cleanupOldDrivers, 30000);
          setInterval(() => {
            const now = Date.now();
            let changed = false;
            pendingJobs = pendingJobs.filter(job => {
              if (now - job.receivedAt >= 30000) {
                updateJobStatus(job.job, 'expired');
                changed = true;
                return false;
              }
              return true;
            });
            if (changed) savePendingJobs();
          }, 10000);
        });
        client.on('message', (topic, message) => {
          try {
            const data = JSON.parse(message.toString());
            // üëá NEW: Handle passenger presets FIRST
            if (topic === `drivers/${DRIVER_ID}/presets`) {
              handlePassengerPreset(data);
              return;
            }
            if (topic.startsWith("pubs/requests/")) {
              const jobId = data.job;
              // ‚úÖ Use global seenJobIds to prevent duplicates
              if (seenJobIds.has(jobId)) {
                console.log("‚è≠Ô∏è Skipping duplicate job:", jobId);
                return;
              }
              seenJobIds.add(jobId);
              pendingJobs.push({ ...data, receivedAt: Date.now() });
              savePendingJobs();
              addJobToHistory(data, 'queued');
              if (driverPresence === 'available' && !isJobActive) {
                processNextJob();
              } else if (driverPresence === 'busy') {
                if ('speechSynthesis' in window) {
                  const u = new SpeechSynthesisUtterance("New job queued. You are set to busy.");
                  u.lang = 'en-GB';
                  u.rate = 0.9;
                  speechSynthesis.speak(u);
                }
                const btn = document.getElementById('menuBtn');
                btn.style.transform = 'scale(1.1)';
                btn.style.backgroundColor = '#ff6b35';
                setTimeout(() => {
                  btn.style.transform = '';
                  btn.style.backgroundColor = '#FFD700';
                }, 600);
              }
            }
            if (topic.startsWith("jobs/") && topic.endsWith(`/result/${DRIVER_ID}`)) {
              const jobId = topic.split('/')[1];
              if (data.result === "won") {
                statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job allocated! Pickup: ' + (currentJob?.pubName || 'unknown');
                updateJobStatus(jobId, 'allocated');
                const modal = document.getElementById('jobWonModal');
                modal.style.display = 'flex';
                if ('speechSynthesis' in window) {
                  const utterance = new SpeechSynthesisUtterance("You won the job!");
                  utterance.lang = 'en-GB';
                  speechSynthesis.speak(utterance);
                }
                document.getElementById('closeJobWonModal').onclick = () => {
                  modal.style.display = 'none';
                };
              } else if (data.result === "lost") {
                statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚ùå Bid lost. Better luck next time!';
                updateJobStatus(jobId, 'lost');
              } else if (data.result === "too_late") {
                statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚è∞ Bid too late - job expired';
                updateJobStatus(jobId, 'expired');
              } else if (data.result === "job_timeout") {
                statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚è∞ Job expired - no valid bids received';
                updateJobStatus(jobId, 'expired');
              }
            }
            if (topic.startsWith("jobs/") && topic.endsWith("/status")) {
              const jobId = topic.split('/')[1];
              if (data.driver === DRIVER_ID) {
                const validStatuses = ['allocated', 'completed', 'lost', 'rejected', 'no_drivers_responded', 'no_acceptance', 'no_valid_acceptance'];
                if (validStatuses.includes(data.status)) {
                  if (data.status === "allocated") {
                    statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job allocated! Pickup: ' + (currentJob?.pubName || 'unknown');
                    updateJobStatus(jobId, 'allocated');
                  } else if (data.status === "lost") {
                    statusEl.innerHTML = '<span class="gps-source gps-network"></span>‚ùå Bid lost. Better luck next time!';
                    updateJobStatus(jobId, 'lost');
                  } else if (data.status === "rejected") {
                    statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚ùå Job rejected';
                    updateJobStatus(jobId, 'rejected');
                  } else if (data.status === "completed") {
                    statusEl.innerHTML = '<span class="gps-source gps-gps"></span>‚úÖ Job completed';
                    updateJobStatus(jobId, 'completed');
                  } else if (data.status === "no_drivers_responded") {
                    statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚ö†Ô∏è No drivers responded';
                    updateJobStatus(jobId, 'expired');
                  } else if (data.status === "no_acceptance") {
                    statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚ö†Ô∏è No acceptance received';
                    updateJobStatus(jobId, 'expired');
                  } else if (data.status === "no_valid_acceptance") {
                    statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚ö†Ô∏è No valid acceptance';
                    updateJobStatus(jobId, 'expired');
                  }
                }
              }
            }
            if (topic === CHAT_GROUP_TOPIC) {
              if (data.sender !== DRIVER_ID) {
                addMessage('group', data.sender, data.text, data.timestamp);
              }
            }
            if (topic.startsWith(`chat/private/${DRIVER_ID}/`)) {
              const sender = topic.split('/')[2];
              if (sender !== DRIVER_ID) {
                addMessage(sender, data.sender, data.text, data.timestamp);
              }
            }
            if (topic.startsWith("drivers/") && topic.endsWith("/location")) {
              const driverId = topic.split('/')[1];
              if (driverId === DRIVER_ID) return;
              otherDrivers[driverId] = data;
              driverStatus[driverId] = data.ts;
              updateChatList();
            }
            if (topic.startsWith("drivers/") && topic.endsWith("/status")) {
              const driverId = topic.split('/')[1];
              if (driverId === DRIVER_ID) return;
              driverStatus[driverId] = data.ts;
              updateChatList();
            }
          } catch (e) {
            console.error("MQTT message parse error:", e);
          }
        });
        client.on('error', (err) => {
          console.error("MQTT error:", err);
          statusEl.innerHTML = '<span class="gps-source gps-poor"></span>‚ùå MQTT Error: ' + err.message;
        });
      }
      function cleanupOldDrivers() {
        const now = Date.now();
        Object.keys(otherDrivers).forEach(id => {
          if (now - (driverStatus[id] || 0) > 60000) {
            delete otherDrivers[id];
            delete driverStatus[id];
          }
        });
        updateChatList();
      }

      // ‚úÖ FIXED FCM FUNCTIONS
async function requestFCMToken() {
  try {
    const permission = await Notification.requestPermission();
    if (permission !== 'granted') return null;

    // Register SW at correct path & scope
    const registration = await navigator.serviceWorker.register(
      '/blackcabunite/firebase-messaging-sw.js',
      { scope: '/blackcabunite/' }
    );

    fcmToken = await messaging.getToken({
      vapidKey: "BJzV8Vx2sDvF6u9vGqK7vV5vD0U6X1aB5e4R3cN2mL1kJ0hI9gF8dC7bA6yZ5xW4vU3tS2rQ1pO0nM",
      serviceWorkerRegistration: registration
    });

    if (fcmToken) {
      console.log('‚úÖ FCM Token:', fcmToken.substring(0, 12) + '...');
      publishFcmToken(); // will retry if MQTT not ready
    }
    return fcmToken;
  } catch (err) {
    console.error('‚ùå FCM setup failed:', err);
  }
}
      function publishFcmToken() {
        if (!client || !client.connected) {
          console.log("‚è≥ MQTT not connected yet; will retry on connect");
          return;
        }
        if (!fcmToken || !DRIVER_ID) {
          console.warn("‚ö†Ô∏è Missing FCM token or DRIVER_ID");
          return;
        }
        const payload = {
          driver: DRIVER_ID,
          fcmToken: fcmToken,
          ts: Date.now()
        };
        client.publish(`drivers/${DRIVER_ID}/fcm`, JSON.stringify(payload));
        console.log("üì§ Published FCM token via MQTT");
      }

      // ‚úÖ Request FCM token AFTER DRIVER_ID is set
      if ('serviceWorker' in navigator && Notification.permission !== 'denied') {
        requestFCMToken();
      }

      function renderCurrentView() {
        if (currentView === 'currentJob') {
          renderCurrentJob();
        } else if (currentView === 'jobHistory') {
          renderJobHistory();
        } else if (currentView === 'chat') {
          renderChatView();
        } else if (currentView === 'settings') {
          renderSettingsView();
        }
      }
      menuNavBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          menuNavBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentView = btn.dataset.view;
          renderCurrentView();
        });
      });
      document.getElementById('acceptBtn').addEventListener('click', () => respondToJob(true));
      document.getElementById('rejectBtn').addEventListener('click', () => respondToJob(false));
      // Status dropdown toggle
      const appTitleContainer = document.getElementById('appTitleContainer');
      const statusDropdown = document.getElementById('statusDropdown');
      appTitleContainer.addEventListener('click', (e) => {
        e.stopPropagation();
        statusDropdown.style.display = statusDropdown.style.display === 'flex' ? 'none' : 'flex';
      });
      document.querySelectorAll('.status-option').forEach(option => {
        option.addEventListener('click', () => {
          const newStatus = option.dataset.status;
          setDriverPresence(newStatus);
          statusDropdown.style.display = 'none';
        });
      });
      document.getElementById('logOffBtn').addEventListener('click', handleLogOff);
      document.addEventListener('click', () => {
        statusDropdown.style.display = 'none';
      });
      // Prevent dropdown from closing when clicking inside it
      statusDropdown.addEventListener('click', (e) => {
        e.stopPropagation();
      });
      // Initialize app
        if ('serviceWorker' in navigator && Notification.permission !== 'denied') {
        requestFCMToken();
      }
      initMapImmediately();
    });
  </script>
</body>
</html>



